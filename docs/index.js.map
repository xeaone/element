{
  "version": 3,
  "sources": ["../source/global.ts", "../source/tools.ts", "../source/reference.ts", "../source/attribute-name.ts", "../source/display.ts", "../source/update.ts", "../source/event.ts", "../source/attribute-value.ts", "../source/text.ts", "../source/action.ts", "../source/bind.ts", "../source/initialize.ts", "../source/dash.ts", "../source/define.ts", "../source/style.ts", "../source/index.ts", "../client/modules/highlight.ts", "../client/root.ts", "../client/modules/color.ts", "../client/guide.ts", "../client/performance.ts", "../client/all.ts", "../client/index.ts"],
  "sourcesContent": ["import { Global } from './types';\n\nexport const global: Global = (globalThis as any).XGLOBAL ?? ((globalThis as any).XGLOBAL = Object.freeze({\n    // QueueNext: undefined,\n    // QueueCurrent: undefined,\n\n    Bound: new WeakMap(),\n    BindersCache: new Set(),\n\n    // GlobalBinders: new Set(),\n    // LocalBinders: new Set(),\n    // QueueBinders: new Set(),\n\n    // VirtualCache: new WeakMap(),\n\n    TemplatesCache: new WeakMap(),\n    ContainersCache: new WeakMap(),\n\n    MarkSymbol: Symbol('mark'),\n    ViewSymbol: Symbol('view'),\n\n    TemplateSymbol: Symbol('template'),\n    VariablesSymbol: Symbol('variables'),\n}));\n\nexport const {\n    // QueueNext,\n    // QueueCurrent,\n\n    BindersCache,\n\n    // GlobalBinders,\n    // LocalBinders,\n    // QueueBinders,\n\n    // VirtualCache,\n\n    TemplatesCache,\n    ContainersCache,\n\n    MarkSymbol,\n    ViewSymbol,\n    TemplateSymbol,\n    VariablesSymbol,\n} = global;\n", "\n// globalThis.NodeFilter = globalThis.NodeFilter || {\n//     FILTER_ACCEPT: 1,\n//     FILTER_REJECT: 2,\n//     FILTER_SKIP: 3,\n//     SHOW_ALL: 0xFFFFFFFF,\n//     SHOW_ELEMENT: 0x1,\n//     SHOW_ATTRIBUTE: 0x2,\n//     SHOW_TEXT: 0x4,\n//     SHOW_CDATA_SECTION: 0x8,\n//     SHOW_ENTITY_REFERENCE: 0x10,\n//     SHOW_ENTITY: 0x20,\n//     SHOW_PROCESSING_INSTRUCTION: 0x40,\n//     SHOW_COMMENT: 0x80,\n//     SHOW_DOCUMENT: 0x100,\n//     SHOW_DOCUMENT_TYPE: 0x200,\n//     SHOW_DOCUMENT_FRAGMENT: 0x400,\n//     SHOW_NOTATION: 0x800,\n// };\n\nexport const {\n    SHOW_TEXT,\n    SHOW_ELEMENT,\n} = NodeFilter;\n\nexport const {\n    TEXT_NODE,\n    COMMENT_NODE,\n    ELEMENT_NODE,\n    ATTRIBUTE_NODE,\n    DOCUMENT_FRAGMENT_NODE,\n} = Node;\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\n// https://www.w3.org/TR/REC-html40/index/attributes.html\nconst patternLink = new RegExp(\n    [\n        '^[.@$]?(',\n        [\n            'src',\n            'href',\n            'data',\n            'action',\n            'srcdoc',\n            'xlink:href',\n            'cite',\n            'formaction',\n            'ping',\n            'poster',\n            'background',\n            'classid',\n            'codebase',\n            'longdesc',\n            'profile',\n            'usemap',\n            'icon',\n            'manifest',\n            'archive',\n        ].join('|'),\n        ')',\n    ].join(''),\n    'i',\n);\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\nconst patternBool = new RegExp(\n    [\n        '^[.@$]?(',\n        [\n            'hidden',\n            'allowfullscreen',\n            'async',\n            'autofocus',\n            'autoplay',\n            'checked',\n            'controls',\n            'default',\n            'defer',\n            'disabled',\n            'formnovalidate',\n            'inert',\n            'ismap',\n            'itemscope',\n            'loop',\n            'multiple',\n            'muted',\n            'nomodule',\n            'novalidate',\n            'open',\n            'playsinline',\n            'readonly',\n            'required',\n            'reversed',\n            'selected',\n        ].join('|'),\n        ')',\n    ].join(''),\n    'i',\n);\n\nconst patternAnimation = /^[.@$]?onanimation$/i;\nconst patternTimeout = /^[.@$]?ontimeout$/i;\nconst patternOnce = /^[.@$]?ononce$/i;\nconst patternValue = /^[.@$]?value$/i;\nconst patternOn = /^[.@$]?on/i;\nconst patternMarker = /^x-[0-9]{10}-x$/i;\n// const safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\nconst safePattern = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\n\nexport const isLink = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternLink.test(data) : false;\n};\n\nexport const isBool = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternBool.test(data) : false;\n};\n\nexport const isIterable = function (data: any): boolean {\n    return data && typeof data !== 'string' && typeof data[Symbol.iterator] === 'function';\n};\n\nexport const isAnimation = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternAnimation.test(data) : false;\n};\n\nexport const isOnce = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternOnce.test(data) : false;\n};\n\nexport const isTimeout = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternTimeout.test(data) : false;\n};\n\nexport const isValue = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternValue.test(data) : false;\n};\n\nexport const hasOn = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternOn.test(data) : false;\n};\n\nexport const isMarker = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternMarker.test(data) : false;\n};\n\nexport const matchMarker = function (data: string, marker: string): boolean {\n    return data && marker &&\n            typeof data === 'string' &&\n            typeof marker === 'string'\n        ? data.toLowerCase() === marker.toLowerCase()\n        : false;\n};\n\nexport const hasMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ? data.indexOf(marker) !== -1 : false;\n};\n\nexport const sliceOn = function (data: string): string {\n    return data && typeof data === 'string' ? data.replace(patternOn, '') : '';\n};\n\nexport const isConnected = function (node: Node): boolean {\n    if (node.nodeType === Node.ATTRIBUTE_NODE) {\n        return node.parentNode?.isConnected ?? false;\n    } else {\n        return node.isConnected;\n    }\n    // return (\n    //     !node.ownerDocument ||\n    //     !(\n    //       node.ownerDocument.compareDocumentPosition(node) &\n    //       node.DOCUMENT_POSITION_DISCONNECTED\n    //     )\n    // );\n};\n\n// export const includes = function (item: string | Array<any>, search: any) {\n//     return item.indexOf(search) !== -1;\n// };\n\nexport const mark = function (): string {\n    return `x-${`${Math.floor(Math.random() * Date.now())}`.slice(0, 10)}-x`;\n};\n\nexport const dangerousLink = function (data: string): boolean {\n    if (data === '') return false;\n    if (typeof data !== 'string') return false;\n    return safePattern.test(data) ? false : true;\n};\n\n/**\n *  DOM mod methods\n */\n\nexport const removeBetween = function (start: Node, end: Node) {\n    let node = end.previousSibling;\n    while (node && node !== start) {\n        node.parentNode?.removeChild(node);\n        node = end.previousSibling;\n    }\n};\n\nexport const removeNode = function (node: Node): void {\n    (node.parentNode as Node).removeChild(node);\n};\n\nexport const beforeNode = function (node: Node | string, child: Node): void {\n    if (!(node instanceof Node)) node = (child.ownerDocument as Document).createTextNode(`${node}`);\n    (child.parentNode as Node).insertBefore(node, child);\n};\n\nexport const afterNode = function (node: Node | string, child: Node): void {\n    if (!(node instanceof Node)) node = (child.ownerDocument as Document).createTextNode(`${node}`);\n    (child.parentNode as Node).insertBefore(node, child.nextSibling);\n};\n\nexport const replaceNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).replaceChild(node, child);\n};\n\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n    }\n\n    for (const node of nodes) {\n        element.appendChild(\n            typeof node === 'string' ? (element.ownerDocument as Document).createTextNode(node) : node,\n        );\n    }\n};\n\n/**\n * Attr DOM\n */\n\nexport const addAttribute = function (owner: Element, attribute: Attr): Attr {\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const createAttribute = function (owner: Element, name: string, value?: string): Attr {\n    const attribute = owner.ownerDocument.createAttribute(name);\n    attribute.value = value ?? '';\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const removeAttribute = function (node: Attr): Attr {\n    return (node.ownerElement as Element).removeAttributeNode(node);\n};\n\n/**\n * Node methods\n */\n\nexport const isText = function (node: Node | null): boolean {\n    return node?.nodeType === TEXT_NODE;\n};\n\nexport const isAttribute = function (node: Node | null): boolean {\n    return node?.nodeType === ATTRIBUTE_NODE;\n};\n\nexport const isElement = function (node: Node | null): boolean {\n    return node?.nodeType === ELEMENT_NODE;\n};\n\nexport const isComment = function (node: Node | null): boolean {\n    return node?.nodeType === COMMENT_NODE;\n};\n", "import { ReferenceType } from './types';\n\n// if (!('WeakRef' in globalThis)) {\n//     globalThis['WeakRef'] = (function () {\n//         const wm = new WeakMap();\n//         const WeakRef = function (target) {\n//             wm.set(this, target);\n//         };\n//         WeakRef.prototype.deref = function () {\n//             return wm.get(this);\n//         };\n//         return WeakRef as any;\n//     })();\n// }\n\nexport const Reference = function <T>(data: T): ReferenceType<T> {\n    return {\n        data: data instanceof Node ? new WeakRef(data) : data,\n        get: function <T>(): T | undefined {\n            if (this.data instanceof WeakRef) {\n                return this.data.deref();\n            } else {\n                return this.data;\n            }\n        },\n        set: function <T>(data: T): T | undefined {\n            if (data instanceof Node) {\n                this.data = new WeakRef(data);\n                return data;\n            } else {\n                this.data = data;\n                return data;\n            }\n        },\n    };\n};\n", "import { hasOn, isBool, isLink, isValue, sliceOn } from './tools';\nimport { Binder } from './types';\n\nexport const attributeName = function (element: Element, binder: Binder, source: any, target: any): void {\n    source = source?.toLowerCase() ?? '';\n    target = target?.toLowerCase() ?? '';\n\n    // console.log('binder:', binder, 'source:', source, 'target:', target);\n\n    if (source === target) {\n        return;\n    }\n\n    if (hasOn(source)) {\n        if (typeof binder.value === 'function') {\n            element.removeEventListener(sliceOn(source), binder.value, true);\n        }\n    } else if (isValue(source)) {\n        element.removeAttribute(source);\n        Reflect.set(element, source, null);\n    } else if (isBool(source)) {\n        element.removeAttribute(source);\n        Reflect.set(element, source, false);\n    } else if (isLink(source)) {\n        element.removeAttribute(source);\n        Reflect.deleteProperty(element, source);\n    } else if (source) {\n        element.removeAttribute(source);\n        Reflect.deleteProperty(element, source);\n    }\n\n    if (hasOn(target)) {\n        return;\n    } else if (isBool(target)) {\n        binder.value = '';\n        element.setAttribute(target, '');\n        Reflect.set(element, target, true);\n    } else if (target) {\n        element.setAttribute(target, '');\n        Reflect.set(element, target, null);\n    }\n\n    binder.name = target || '';\n};\n", "export const display = function (data: any): string {\n    switch (`${data}`) {\n        case 'NaN':\n            return '';\n        case 'null':\n            return '';\n        case 'undefined':\n            return '';\n    }\n\n    switch (typeof data) {\n        case 'string':\n            return data;\n        case 'number':\n            return `${data}`;\n        case 'bigint':\n            return `${data}`;\n        case 'boolean':\n            return `${data}`;\n        case 'symbol':\n            return String(data);\n        case 'object':\n            return JSON.stringify(data);\n    }\n\n    throw new Error('XElement - display type not handled');\n};\n", "import { BindersCache } from './global';\nimport { action } from './action';\n\nlet Next: Promise<void> | undefined;\nlet Current: Promise<void> | undefined;\n\nexport const next = async function (): Promise<void> {\n    console.log('next');\n    await Current;\n    await new Promise((resolve) => {\n        queueMicrotask(async () => {\n            Next = undefined;\n            await update();\n            resolve(undefined);\n        });\n    });\n};\n\nexport const update = async function (): Promise<void> {\n    console.log('update');\n    if (Current) {\n        if (Next) {\n            await Next;\n        } else {\n            Next = next();\n            await Next;\n        }\n    } else {\n        Current = new Promise((resolve) => {\n            queueMicrotask(async () => {\n                const binders = BindersCache.values();\n\n                for (const binder of binders) {\n                    try {\n                        await action(binder);\n                    } catch (error) {\n                        console.error(error);\n                    }\n                }\n\n                Current = undefined;\n\n                resolve();\n            });\n        });\n\n        await Current;\n    }\n};\n\nexport const updateAllSync = function () {\n    const binders = BindersCache.values();\n\n    for (const binder of binders) {\n        try {\n            action(binder);\n        } catch (error) {\n            console.error(error);\n        }\n    }\n\n}\n\n// const stack: Binder[] = [];\n// export const update = async function (binders?: Binder[]): Promise<void> {\n//     if (binders && binders.length) {\n//         stack.push(...binders);\n//     }\n\n//     if (Current) {\n//         await Current;\n//     } else {\n//         Current = new Promise((resolve) => {\n//             queueMicrotask(async () => {\n//                 let binder: Binder | undefined = stack?.shift();\n\n//                 while (binder) {\n//                     try {\n//                         await action(binder);\n//                     } catch (error) {\n//                         console.error(error);\n//                     }\n\n//                     binder = stack?.shift();\n//                 }\n\n//                 Current = undefined;\n\n//                 resolve();\n//             });\n//         });\n\n//         await Current;\n//     }\n// };\n", "import { Binder } from './types';\n// import { update } from './update';\n\nexport const event = function (binder: Binder) {\n    return {\n        get target() {\n            return binder?.node;\n        },\n        // update,\n        query(selector: string): Element | null {\n            return (binder?.node?.getRootNode() as Element)?.querySelector(selector);\n        },\n    };\n};\n", "import { dangerousLink, hasOn, isBool, isLink, isOnce, isValue, sliceOn } from './tools';\nimport { display } from './display';\nimport { update } from './update';\nimport { Binder } from './types';\nimport { event } from './event';\nimport { isTimeout } from './tools';\n\nconst isRadioChecked = function (element: Element) {\n    if (element.nodeName === 'INPUT' && (element as HTMLInputElement).type === 'radio') {\n        const radios = element.ownerDocument.querySelectorAll<HTMLInputElement>(`input[name=\"${(element as HTMLInputElement).name}\"]`);\n        for (const radio of radios) {\n            if (radio.checked) {\n                return radio.checked;\n            }\n        }\n    }\n\n    return false;\n};\n\nexport const attributeValue = function (element: Element, binder: Binder, source: any, target: any): void {\n    if (source === target) {\n        return;\n    }\n\n    if (!binder.name) {\n        console.warn('attribute binder name required');\n        return;\n    }\n\n    if (isValue(binder.name)) {\n        if (element.nodeName === 'SELECT') {\n            const options = (element as HTMLSelectElement).options as HTMLOptionsCollection;\n            const array = Array.isArray(target);\n            for (const option of options) {\n                option.selected = array ? target.includes(option.value) : `${target}` === option.value;\n            }\n        } else {\n            binder.value = display(target);\n            element.setAttribute(binder.name, binder.value);\n            Reflect.set(element, binder.name, binder.value);\n        }\n    } else if (isLink(binder.name)) {\n        binder.value = encodeURI(target);\n\n        if (dangerousLink(binder.value)) {\n            element.removeAttribute(binder.name);\n            console.warn(`XElement - attribute name \"${binder.name}\" and value \"${binder.value}\" not allowed`);\n            return;\n        }\n\n        element.setAttribute(binder.name, binder.value);\n        Reflect.set(element, binder.name, binder.value);\n    } else if (isBool(binder.name)) {\n        const bool = !!target;\n\n        if (bool) {\n            element.setAttribute(binder.name, '');\n        } else {\n            element.removeAttribute(binder.name);\n        }\n\n        Reflect.set(element, binder.name, bool);\n    } else if (hasOn(binder.name)) {\n        // handle onanimation ontimeout\n\n        if (element.hasAttribute(binder.name)) {\n            element.removeAttribute(binder.name);\n        }\n\n        if (typeof binder.value === 'function') {\n            element.removeEventListener(\n                sliceOn(binder.name),\n                binder.value,\n                source?.[1] ?? true,\n            );\n        }\n\n        const method = typeof target === 'function' ? target : target?.[0];\n\n        if (typeof method !== 'function') {\n            return console.warn(`XElement - attribute name \"${binder.name}\" expected a function`);\n        }\n\n        let oldResult: any;\n        binder.value = function () {\n            if (element.nodeName === 'INPUT' && (element as HTMLInputElement).type === 'radio') {\n                const radios = element.ownerDocument.querySelectorAll<HTMLInputElement>(`input[name=\"${(element as HTMLInputElement).name}\"]`);\n                for (const radio of radios) {\n                    if (radio.checked) {\n                        oldResult = radio.checked;\n                    }\n                }\n            }\n\n            const newResult = method.call(this, event(binder));\n\n            if (newResult !== oldResult) {\n                oldResult = newResult;\n                update();\n            }\n\n            return newResult;\n        };\n\n        if (isOnce(binder.name)) {\n            binder.value();\n        } else if (isTimeout(binder.name)) {\n            setTimeout(binder.value, target?.[1]);\n        } else {\n            element.addEventListener(sliceOn(binder.name), binder.value, target?.[1] ?? true);\n        }\n    } else {\n        binder.value = target;\n        element.setAttribute(binder.name, binder.value);\n        Reflect.set(element, binder.name, binder.value);\n    }\n};\n\n// const attribute = function (node: Attr, binder: Binder, source: any, target: any) {\n//     const name = node.name;\n//     const value = node.value;\n\n//     if (hasOn(name)) {\n\n//         if (isAnimation(name)) {\n//             // const variable = binder.result;\n//             const isArray = Array.isArray(binder.result);\n//             const method = isArray ? binder.result[ 0 ] : binder.result;\n//             const handle = async () => {\n//                 if (binder.owner?.isConnected) {\n//                     const result = method();\n//                     if (binder.result === result) {\n//                         requestAnimationFrame(handle);\n//                     } else {\n//                         binder.result = result;\n//                         await update();\n//                         requestAnimationFrame(handle);\n//                     }\n//                 } else {\n//                     requestAnimationFrame(handle);\n//                 }\n//             };\n//             requestAnimationFrame(handle);\n//         } else if (isTimeout(name)) {\n//             // const variable = binder.variable;\n//             // const isArray = Array.isArray(variable);\n//             // const method = isArray ? variable[ 0 ] : variable;\n//             // const time = isArray ? variable[ 1 ] : undefined;\n\n//             const isArray = Array.isArray(binder.result);\n//             const method = isArray ? binder.result[ 0 ] : binder.result;\n//             const time = isArray ? binder.result[ 1 ] : undefined;\n//             const handle = async () => {\n//                 const result = method();\n//                 if (binder.result === result) {\n//                     return;\n//                 } else {\n//                     binder.result = result;\n//                     await update();\n//                 }\n//             };\n//             setTimeout(handle, time);\n//         } else {\n//             const owner = binder.owner;\n//             if (owner) {\n//                 const eventName = name.substring(2);\n//                 const isArray = Array.isArray(result);\n//                 const [ method, options ] = isArray ? result : [ result, undefined ];\n//                 if (typeof method === 'function') {\n//                     // owner.removeEventListener(eventName, result);\n//                     owner.addEventListener(eventName, async function (event) {\n//                         const returned = method(event);\n//                         if (binder.meta.returned !== returned) {\n//                             binder.meta.returned = returned;\n//                             await update();\n//                         }\n//                     }, options);\n//                     intersectionObserver.observe(owner);\n//                 } else {\n//                     console.error(`${name} requiures function or array with function`);\n//                 }\n//             }\n//         }\n\n//         const owner = binder.owner;\n//         if (owner) {\n//             owner.removeAttributeNode(node);\n//         }\n\n//     // } else if (isMarker(name)) {\n//     } else if (value === '') {\n//         if (name === result) {\n//             if (!binder.owner?.hasAttribute(result)) {\n//                 addAttribute(binder.owner as Element, node);\n//                 Reflect.set(binder.owner as Element, result, true);\n//             }\n//         } else {\n//             if (result) {\n//                 removeAttribute(node);\n//                 binder.replace(createAttribute(binder.owner as Element, result));\n//                 Reflect.set(binder.owner as Element, result, true);\n//             } else {\n//                 removeAttribute(node);\n//                 Reflect.set(binder.owner as Element, result, false);\n//             }\n//         }\n//     } else if (result instanceof Attr) {\n\n//     } else {\n//         node.value = result;\n//     }\n// };\n", "import { afterNode, beforeNode, isIterable, removeBetween, removeNode, replaceNode } from './tools';\nimport { MarkSymbol, ViewSymbol } from './global';\nimport { display } from './display';\nimport { Binder } from './types';\n\nconst iterableDisplay = function (data: any): Node | string {\n    return data?.[ViewSymbol] ? data() : data instanceof Node ? data : display(data);\n};\n\nexport const text = function (node: Text, binder: Binder, source: any, target: any): void {\n    if (target === null || target === undefined) {\n        if (node.textContent !== '') {\n            node.textContent = '';\n        }\n    } else if (target?.[ViewSymbol]) {\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        removeBetween(binder.start, binder.end);\n        beforeNode(target(), binder.end);\n    } else if (target instanceof DocumentFragment) {\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        removeBetween(binder.start, binder.end);\n        beforeNode(target, binder.end);\n    } else if (isIterable(target)) {\n        // console.log(target);\n\n        if (binder.length === undefined) {\n            binder.length = 0;\n        }\n\n        if (!binder.results) {\n            binder.results = [];\n        }\n\n        if (!binder.markers) {\n            binder.markers = [];\n        }\n\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        const oldLength = binder.length;\n        const newLength = target.length;\n        const commonLength = Math.min(oldLength, newLength);\n\n        // todo: make this more efficient\n        for (let index = 0; index < commonLength; index++) {\n            if (\n                target[index] === binder.results[index] ||\n                target[index]?.[ViewSymbol] && binder.results[index]?.[ViewSymbol] && target[index]?.[MarkSymbol] === binder.results[index]?.[MarkSymbol]\n            ) continue;\n\n            const marker = binder.markers[index];\n            const last = binder.markers[index + 1] ?? binder.end;\n            while (last.previousSibling && last.previousSibling !== marker) {\n                removeNode(last.previousSibling);\n            }\n\n            const child = iterableDisplay(target[index]);\n            afterNode(child, marker);\n            console.log(binder.results[index], target[index], child, marker);\n\n            binder.results[index] = target[index];\n        }\n\n        if (oldLength < newLength) {\n            while (binder.length !== target.length) {\n                const marker = document.createTextNode('');\n                const child = iterableDisplay(target[binder.length]);\n\n                binder.markers.push(marker);\n                binder.results.push(target[binder.length]);\n\n                beforeNode(marker, binder.end);\n                beforeNode(child, binder.end);\n                binder.length++;\n            }\n        } else if (oldLength > newLength) {\n            // const last = binder.markers[ target.length - 1 ];\n\n            // while (binder.length !== target.length) {\n            //     const previous = binder.end.previousSibling;\n            //     if (previous === last) break;\n            //     removeNode(previous as Node);\n            // }\n\n            const marker = binder.markers[target.length - 1];\n            const last = binder.end;\n            while (last.previousSibling && last.previousSibling !== marker) {\n                removeNode(last.previousSibling);\n            }\n\n            binder.length = target.length;\n            binder.results.length = target.length;\n            binder.markers.length = target.length;\n        }\n    } else if (target instanceof Node) {\n        replaceNode(target, node);\n    } else {\n        if (node.textContent === `${target}`) {\n            return;\n        } else {\n            node.textContent = `${target}`;\n        }\n    }\n};\n", "import { attributeName } from './attribute-name';\nimport { attributeValue } from './attribute-value';\nimport { hasOn, isConnected } from './tools';\nimport { ViewSymbol } from './global';\nimport { Binder } from './types';\nimport { event } from './event';\nimport { text } from './text';\nimport { MarkSymbol } from './global';\n\n/**\n * @module Action\n * @todo need to handle element name changes\n * @todo need to handle attribute name changes\n * @todo\n */\n\nconst comment = function (node: Comment, data: any, source: any, target: any): void {\n    console.warn('comment action not implemented');\n};\n\nconst element = function (node: Element, data: any, source: any, target: any): void {\n    console.warn('element action not implemented');\n};\n\nexport const action = function (binder: Binder) {\n    const node = binder.node;\n\n    if (!node) {\n        return;\n    }\n\n    // this optimization could prevent disconnected nodes from being render when re/connected\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n    if (!isConnected(node) && binder.isInitialized) {\n        return;\n    }\n\n    const variable = binder.variable;\n    const isFunction = typeof variable === 'function';\n    const isInstance = isFunction && (variable as any)[ViewSymbol];\n    const isOnce = binder.type === 3 && hasOn(binder.name);\n    const isReactive = !isInstance && !isOnce && isFunction;\n\n    if (isOnce || isInstance || !isFunction) {\n        binder.remove();\n    }\n\n    const target = isReactive ? variable(event(binder)) : isInstance ? variable() : variable;\n\n    const source = binder.source;\n    if (\n        'source' in binder &&\n        (\n            source === target ||\n            source?.[ViewSymbol] && target?.[ViewSymbol] && source?.[MarkSymbol] === target?.[MarkSymbol]\n        )\n    ) {\n        return;\n    }\n\n    if (binder.type === 1) {\n        element(node as Element, binder, source, target);\n    } else if (binder.type === 2) {\n        attributeName(node as Element, binder, source, target);\n    } else if (binder.type === 3) {\n        attributeValue(node as Element, binder, source, target);\n    } else if (binder.type === 4) {\n        text(node as Text, binder, source, target);\n    } else {\n        throw new Error('instruction type not valid');\n    }\n\n    binder.source = target;\n    binder.isInitialized = true;\n};\n", "import { Binder, BinderType, ReferenceType, Variables } from './types';\nimport { BindersCache } from './global';\n// import { update } from './update';\n// import { action } from './action';\n\n// const ro = new ResizeObserver(function (entries) {\n//     console.log(arguments);\n//     // for (const entry of entries) {\n//     //     const { target } = entry;\n//     //     if (target.isConnected) {\n//     //         const childBinder = Bound.get(target);\n//     //         const parentBinder = Bound.get(target.parentElement);\n//     //         console.log(childBinder, parentBinder, childBinder.value, parentBinder.value);\n//     //         if (childBinder && parentBinder && childBinder.value === parentBinder.value) {\n//     //             target.selected = true;\n//     //         }\n//     //         ro.unobserve(target);\n//     //     }\n//     // }\n// });\n\n// const observed: WeakMap<Element, Array<Binder>> = new WeakMap();\n// const io = new IntersectionObserver(async (entries) => {\n//     for (const entry of entries) {\n//         const { target } = entry;\n//         // if (target.isConnected) {\n//         // } else {\n//         //     console.log(target.isConnected, target);\n//         // }\n//         const binders = observed.get(target) as Binder[];\n\n//         for (const binder of binders) {\n//             try {\n//                 await action(binder);\n//             } catch (error) {\n//                 console.error(error);\n//             }\n//         }\n\n//     }\n// }, {\n//     threshold: 1,\n//     // rootMargin: '100000%',\n//     root: document.documentElement,\n// });\n\nexport const bind = function (\n    type: BinderType,\n    index: number,\n    variables: Variables,\n    referenceNode: ReferenceType<Node>,\n    referenceName?: ReferenceType<any>,\n    referenceValue?: ReferenceType<any>,\n) {\n    const binder: Binder = {\n        type,\n\n        // index,\n        // variables,\n        isInitialized: false,\n\n        get variable() {\n            return variables[index];\n        },\n\n        set variable(data: any) {\n            variables[index] = data;\n        },\n\n        get node() {\n            const node = referenceNode.get();\n            if (node) {\n                return node;\n            } else {\n                BindersCache.delete(this);\n                return undefined;\n            }\n        },\n\n        get name() {\n            return (referenceName as ReferenceType<any>).get();\n        },\n\n        set name(name: string) {\n            (referenceName as ReferenceType<any>).set(name);\n        },\n\n        get value() {\n            return (referenceValue as ReferenceType<any>).get();\n        },\n\n        set value(value: string) {\n            (referenceValue as ReferenceType<any>).set(value);\n        },\n\n        remove() {\n            BindersCache.delete(this);\n        },\n\n        add() {\n            BindersCache.add(this);\n        },\n    };\n\n    // const node = binder.node;\n    // const parent = node?.parentElement;\n\n    // if (node instanceof Element) {\n    //     const binders = observed.get(node);\n    //     if (binders) {\n    //         binders.push(binder);\n    //     } else {\n    //         io.observe(node);\n    //         observed.set(node, [binder]);\n    //     }\n    // } else if (parent instanceof Element) {\n    //     if (!document.contains(parent)) {\n    //         console.log(parent);\n    //     }\n\n    //     const binders = observed.get(parent);\n    //     if (binders) {\n    //         binders.push(binder);\n    //     } else {\n    //         io.observe(parent);\n    //         observed.set(parent, [binder]);\n    //     }\n    // } else {\n    //     // binder.add();\n    //     console.warn('top level reactive text bindings');\n    // }\n\n    binder.add();\n\n    return binder;\n};\n", "import { dangerousLink, ELEMENT_NODE, hasMarker, hasOn, isLink, matchMarker, replaceChildren, SHOW_ELEMENT, SHOW_TEXT, TEXT_NODE } from './tools';\nimport { Binder, Container, Marker, ReferenceType, Template, Variables } from './types';\nimport { ContainersCache } from './global';\nimport { Reference } from './reference';\nimport { action } from './action';\n// import { update } from './update';\nimport { bind } from './bind';\n\nconst FILTER = SHOW_ELEMENT + SHOW_TEXT;\n\nexport const initialize = function (\n    template: Template,\n    variables: Variables,\n    marker: Marker,\n    container?: Container,\n): Element | ShadowRoot | DocumentFragment {\n    if (typeof container === 'string') {\n        const selection = document.querySelector(container);\n        if (!selection) throw new Error('query not found');\n        const cache = ContainersCache.get(selection);\n        if (cache && cache === template) {\n            // update();\n            return selection;\n        } else {\n            ContainersCache.set(selection, template);\n        }\n    } else if (container instanceof Element || container instanceof ShadowRoot) {\n        const cache = ContainersCache.get(container);\n        if (cache && cache === template) {\n            // update();\n            return container;\n        } else {\n            ContainersCache.set(container, template);\n        }\n    }\n\n    const binders: Binder[] = [];\n    const fragment = template.content.cloneNode(true) as DocumentFragment;\n    const walker = document.createTreeWalker(fragment, FILTER, null);\n\n    let node: Node | null;\n    let index = 0;\n\n    while (walker.nextNode()) {\n        node = walker.currentNode;\n        const type = node.nodeType;\n\n        if (type === TEXT_NODE) {\n            let text = node as Text;\n\n            const startIndex = text.nodeValue?.indexOf(marker) ?? -1;\n            if (startIndex === -1) continue;\n\n            if (startIndex !== 0) {\n                text.splitText(startIndex);\n                node = walker.nextNode() as Node | null;\n                text = node as Text;\n            }\n\n            const endIndex = marker.length;\n            if (endIndex !== text.nodeValue?.length) {\n                text.splitText(endIndex);\n            }\n\n            const referenceNode = Reference<Node>(text);\n            const binder = bind(4, index++, variables, referenceNode);\n            binders.unshift(binder);\n            // action(binder);\n        } else if (type === ELEMENT_NODE) {\n            const element = node as Element;\n            const tag = element.tagName;\n\n            if (tag === 'STYLE' || tag === 'SCRIPT') {\n                walker.nextSibling();\n            }\n\n            let referenceNode: ReferenceType<Node> | undefined;\n\n            if (matchMarker(tag, marker)) {\n                referenceNode = Reference(node);\n                const binder = bind(1, index++, variables, referenceNode);\n                binders.unshift(binder);\n                // action(binder);\n            }\n\n            const names = element.getAttributeNames();\n            for (const name of names) {\n                const value = element.getAttribute(name) ?? '';\n                const matchMarkerName = matchMarker(name, marker);\n                const hasMarkerValue = hasMarker(value, marker);\n\n                if (matchMarkerName || hasMarkerValue) {\n                    referenceNode = referenceNode ?? Reference(node);\n\n                    if (matchMarkerName && hasMarkerValue) {\n                        const referenceName = Reference<string>('');\n                        const referenceValue = Reference<string>('');\n                        const binderName = bind(2, index++, variables, referenceNode, referenceName, referenceValue);\n                        const binderValue = bind(3, index++, variables, referenceNode, referenceName, referenceValue);\n                        element.removeAttribute(name);\n                        binders.unshift(binderName);\n                        binders.unshift(binderValue);\n                        // action(binderName);\n                        // action(binderValue);\n                    } else if (matchMarkerName) {\n                        const referenceName = Reference<string>('');\n                        const referenceValue = Reference<string>(value);\n                        const binder = bind(2, index++, variables, referenceNode, referenceName, referenceValue);\n                        element.removeAttribute(name);\n                        binders.unshift(binder);\n                        // action(binder);\n                    } else if (hasMarkerValue) {\n                        const referenceName = Reference<string>(name);\n                        const referenceValue = Reference<string>('');\n                        const binder = bind(3, index++, variables, referenceNode, referenceName, referenceValue);\n                        element.removeAttribute(name);\n                        binders.unshift(binder);\n                        // action(binder);\n                    }\n                } else {\n                    if (isLink(name)) {\n                        if (dangerousLink(value)) {\n                            element.removeAttribute(name);\n                            console.warn(`attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (hasOn(name)) {\n                        element.removeAttribute(name);\n                        console.warn(`attribute name \"${name}\" not allowed`);\n                    }\n                }\n            }\n        } else {\n            console.warn(`walker node type \"${type}\" not handled`);\n        }\n    }\n\n    for (const binder of binders) {\n        action(binder);\n    }\n\n    if (typeof container === 'string') {\n        const selection = document.querySelector(container);\n        if (!selection) throw new Error('query not found');\n        replaceChildren(selection, fragment);\n        return selection;\n    } else if (container instanceof Element || container instanceof ShadowRoot) {\n        replaceChildren(container, fragment);\n        return container;\n    } else {\n        return fragment;\n    }\n};\n", "export const dash = function (data: string): string {\n    data = data.replace(/([a-zA-Z])([A-Z])/g, '$1-$2');\n    data = data.toLowerCase();\n    data = data.includes('-') ? data : `x-${data}`;\n    return data;\n};\n", "import { dash } from './dash';\n\n// export const define = function (tag: string, extend?: string) {\n//     return (constructor: CustomElementConstructor, context: ClassDecoratorContext) => {\n//         context.addInitializer(function () {\n//             const $tag = dash(tag);\n//             const $extend = extend;\n//             customElements.define($tag, constructor, { extends: $extend });\n//         });\n//     };\n// };\n\nexport const define = function (tag: string, extend?: string) {\n    return function (constructor: CustomElementConstructor) {\n        const $tag = dash(tag);\n        const $extend = extend;\n        customElements.define($tag, constructor, { extends: $extend });\n    };\n};\n", "const Sheets: WeakMap<CSSStyleSheet, CSSStyleSheet> = new WeakMap();\n\nexport const style = function (instance: HTMLElement) {\n    if (instance.shadowRoot) {\n        const root = document.getRootNode() as Document;\n\n        instance.shadowRoot.adoptedStyleSheets.push(...root.adoptedStyleSheets);\n\n        for (const rootSheet of root.styleSheets) {\n            let cacheSheet: CSSStyleSheet | undefined = Sheets.get(rootSheet);\n\n            if (!cacheSheet) {\n                cacheSheet = new CSSStyleSheet();\n\n                const { cssRules } = rootSheet;\n                for (const { cssText } of cssRules) {\n                    cacheSheet.insertRule(cssText);\n                }\n\n                Sheets.set(rootSheet, cacheSheet);\n            }\n\n            instance.shadowRoot.adoptedStyleSheets.push(cacheSheet);\n        }\n    }\n};\n\n// export const style = function () {\n//     return function (construct: CustomElementConstructor): typeof construct {\n//         return class extends construct {\n//             constructor(...args: any[]) {\n//                 super(...args);\n//                 if (this.shadowRoot) {\n//                     const root = document.getRootNode() as Document;\n//                     this.shadowRoot.adoptedStyleSheets = [...root.styleSheets];\n//                 }\n//             }\n//         };\n//     };\n// };\n", "import { MarkSymbol, TemplatesCache, TemplateSymbol, VariablesSymbol, ViewSymbol } from './global';\nimport { Initialize, Variables } from './types';\nimport { initialize } from './initialize';\nimport { update, updateAllSync } from './update';\nimport { define } from './define';\nimport { mark } from './tools';\n\nimport { style } from './style';\n\n// const query = (node: Node, selector: Selector) => selector.reduce((n, s) => n[ s ], node);\n\nexport { define, style, update, updateAllSync };\n\n// const connectedEvent = new CustomEvent('connected');\n// const disconnectedEvent = new CustomEvent('disconnected');\n// const intersectionElements: WeakMap<Element, { wasConnected: boolean; isIntersecting: boolean }> = new WeakMap();\n// const intersectionObserver = new IntersectionObserver((entries) => {\n//     for (const entry of entries) {\n//         const intersectionElement = intersectionElements.get(entry.target);\n//         if (!intersectionElement) {\n//             intersectionElements.set(entry.target, { wasConnected: false, isIntersecting: entry.isIntersecting });\n//         } else if (entry.target.isConnected === true && intersectionElement.wasConnected === false) {\n//             intersectionElement.wasConnected = true;\n//             intersectionElement.isIntersecting = entry.isIntersecting;\n//             entry.target.dispatchEvent(connectedEvent);\n//         } else if (entry.target.isConnected === false && intersectionElement.wasConnected === true) {\n//             intersectionElement.wasConnected = false;\n//             intersectionElement.isIntersecting = entry.isIntersecting;\n//             entry.target.dispatchEvent(disconnectedEvent);\n//         } else {\n//             //\n//         }\n//     }\n// }, {\n//     threshold: 1,\n//     // rootMargin: '100000%',\n//     root: document.documentElement,\n// });\n\n// const ro = new ResizeObserver((entries) => {\n//     for (const entry of entries) {\n//         const { target } = entry;\n//         if (target.isConnected) {\n//             // console.log(entry);\n//             console.log(target.isConnected, target.parentElement.value, target.value);\n//             if (target?.parentElement?.value === target.value) {\n//                 target.selected = true;\n//             }\n//             ro.unobserve(target);\n//         }\n//     }\n// });\n\n// const io = new IntersectionObserver((entries) => {\n//     for (const entry of entries) {\n//         const { target } = entry;\n//         if (target.isConnected) {\n//             console.log(target.isConnected, target);\n//             // console.log(entry);\n//             // if (target?.parentElement?.value === target.value) {\n//             //     target.selected = true;\n//             // }\n//             // io.unobserve(target);\n//         }\n//     }\n// }, {\n//     threshold: 1,\n//     // rootMargin: '100000%',\n//     root: document.documentElement,\n// });\n\n// const observer = new MutationObserver(function (records) {\n//     console.log(arguments);\n// });\n// observer.observe(document.body, { childList: true, subtree: true });\n\n/**\n * @description\n * @param strings\n * @param variables\n * @returns {DocumentFragment}\n */\n\nexport const html = function (strings: TemplateStringsArray, ...variables: Variables): Initialize {\n    let marker: string;\n    let template: HTMLTemplateElement;\n\n    const cache = TemplatesCache.get(strings);\n\n    if (cache) {\n        marker = cache.marker;\n        template = cache.template;\n    } else {\n        marker = mark();\n\n        let innerHTML = '';\n\n        const length = strings.length - 1;\n        for (let index = 0; index < length; index++) {\n            innerHTML += `${strings[index]}${marker}`;\n        }\n\n        innerHTML += strings[length];\n\n        template = document.createElement('template');\n        template.innerHTML = innerHTML;\n\n        TemplatesCache.set(strings, { template, marker });\n    }\n\n    const meta = {\n        [ViewSymbol]: true,\n        [MarkSymbol]: marker,\n        [TemplateSymbol]: template,\n        [VariablesSymbol]: variables,\n    };\n\n    return Object.assign(initialize.bind(meta, template, variables, marker), meta);\n};\n", "import js from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/es/languages/javascript.min.js';\nimport xml from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/es/languages/xml.min.js';\nimport hljs from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/es/highlight.min.js';\n\nhljs.registerLanguage('js', function () {\n    return js(...arguments);\n});\n\nhljs.registerLanguage('html', function () {\n    return xml(...arguments);\n});\n\nconst link = document.createElement('link');\nlink.rel = 'stylesheet';\nlink.href = './theme.css';\n// link.href = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css';\ndocument.head.append(link);\n\nexport default function highlight(\n    code: DocumentFragment | Element | Text | (() => DocumentFragment) | string,\n    language?: string,\n): DocumentFragment {\n    if (code instanceof DocumentFragment) {\n        code = [].map.call(\n            code.childNodes,\n            (node) => ((node as Element).outerHTML || (node as Text).textContent || ''),\n        ).join('');\n    } else if (code instanceof Element) {\n        code = code.innerHTML;\n    } else if (code instanceof Text) {\n        code = code.textContent ?? '';\n    } else if (typeof code === 'function') {\n        code = [].map.call(\n            code().childNodes,\n            (node) => ((node as Element).outerHTML || (node as Text).textContent || ''),\n        ).join('');\n    }\n\n    code = code.replace(/^\\n+/, '');\n    // code = code.replace(/\\s*\\n+$/g, '');\n    // code = code.replace(/^\\s*\\n+/g, '');\n\n    if (language) {\n        code = hljs.highlight(code, { language }).value;\n    } else {\n        code = hljs.highlight(code, { language: 'html' }).value;\n        // code = hljs.highlightAuto(code).value;\n    }\n\n    const template = document.createElement('template');\n\n    template.innerHTML = code as string;\n\n    return template.content;\n}\n", "// deno-fmt-ignore-file\nimport { define, html, style } from '../source/index.ts';\nimport highlight from './modules/highlight.ts';\n\nlet count = 0;\n\nconst result = () => html`\n    <strong>${() => `Hello World ${count}`}</strong>\n    <button onclick=${() => count++}>Greet</button>\n`;\n\nconst source = highlight(`\nimport { html } from '/x-element.js';\n\nlet count = 0;\n\nexport default ${result.toString()}(document.body);\n`, 'js');\n\nclass Component extends HTMLElement {\n    #root = this.attachShadow({ mode: 'open' });\n    #count = 0;\n\n    #render = () => html`\n        <strong>${() => `Hello World ${this.#count}`}</strong>\n        <button onclick=${() => this.#count++}>Greet</button>\n    `(this.#root);\n\n    constructor() {\n        super();\n        this.#render();\n    }\n}\ndefine('x-component')(Component);\n\nconst sourceComponent = highlight(`\nimport { html } from '/x-element.js';\n\nexport default ${Component.toString()}\n`, 'js');\n\nexport default html`\n\n    <section>\n\n        <h2>Vision</h2>\n        <h4></h4>\n\n        <div class=\"tiles\">\n            <div class=\"tile\">\n                <h4><span class=\"material-symbols-rounded\">child_care</span> Simple</h4>\n                <span>If you know HTML, JS, and Template Literals then you know how to use XElement.</span>\n            </div>\n            <div class=\"tile\">\n                <h4><span class=\"material-symbols-rounded\">magic_exchange</span> Agnostic</h4>\n                <span>Use XElement with any framework or library - Lit, Vue, React, Angular.</span>\n            </div>\n            <div class=\"tile\">\n                <h4><span class=\"material-symbols-rounded\">commit</span> Reactive</h4>\n                <span>Performant and efficient two way reactive data binding.</span>\n            </div>\n            <div class=\"tile\">\n                <h4><span class=\"material-symbols-rounded\">bolt</span> Fast</h4>\n                <span>Rendering is blazing fast, because XElement only interacts with the dynamic DOM Nodes.</span>\n            </div>\n            <!--\n            <div class=\"tile\">\n                <h4><span class=\"material-symbols-rounded\">deployed_code</span> Small</h4>\n                <span>~(15)KB minified.</span>\n            </div>\n            <div class=\"tile\">\n                <h4><span class=\"material-symbols-rounded\">explore</span> Router</h4>\n                <span>\n                    Client side routing using the new\n                    <a href=\"https://developer.chrome.com/docs/web-platform/navigation-api/\" target=\"_blank\">Navigation API</a>\n                </span>\n            </div>\n            -->\n        </div>\n\n        <h3>Example</h3>\n        <p>\n            Use a tagged Template and invoke it with an Element or query selector parameters to render and mount.\n            Alternatively use the tagged Template without invoking and use the returned DocumentFragment.\n        </p>\n        <pre>${source}</pre>\n        <pre>${result()}</pre>\n\n        <h3>Component Example</h3>\n        <pre>${sourceComponent}</pre>\n        <pre>${new Component()}</pre>\n\n    </section>\n\n`('main');\n\n// const sourceComponent = highlight(`\n// import { html } from '/x-element.js';\n\n// export default class component {\n//     #count = 0;\n//     #root = this.attachShadow({ mode: 'open' });\n//     #fragment = html\\`\n//         <strong>\\${() => \\`Hello World \\${this.#count}\\`}</strong>\n//         <button onclick=\\${() => this.#count++}>Greet</button>\n//     \\`(this.#root);\n// }\n// `, 'js');\n", "export default function Color() {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n\n    for (let i = 0; i < 6; i++) {\n        color += letters[Math.floor(Math.random() * 16)];\n    }\n\n    return color;\n}\n", "import highlight from './modules/highlight.ts';\nimport { html, update } from '../source/index.ts';\nimport Color from './modules/color.ts';\n\nlet input = 'hello world';\nlet checked = true;\nlet color = Color();\nlet active = true;\nlet radioShared = 'two';\nlet radioOne = 'one';\nlet radioTwo = 'two';\nlet boolean = true;\nlet number = 1;\nlet fruit = 'Orange';\nlet fruits = ['Apple', 'Orange', 'Tomato'];\nlet carsSelected = ['ford'];\nlet cars = ['tesla', 'ford', 'chevy'];\n// let tag = 'div';\n\n// deno-fmt-ignore\nconst inputComponent = () => html`\n<div>${() => input}</div>\n<input value=${() => input} oninput=${e => input = e.target.value} />\n`;\n\n// deno-fmt-ignore\nconst checkComponent = () => html`\n<div>${() => checked ? 'Is Checked' : 'Is Not Checked'}</div>\n<input type=\"checkbox\"\n    ${() => checked ? 'checked' : ''}\n    oninput=${e => checked = e.target.checked}\n/>\n`;\n\n// deno-fmt-ignore\nconst radioComponent = () => html`\n<div>${() => radioShared}</div>\n\n<input type=\"radio\" name=\"radio\"\n    value=\"one\"\n    oninput=${(e) => radioShared = e.target.value}\n    checked=${(e) => radioShared === e.target.value}\n/>\n\n<input type=\"radio\" name=\"radio\"\n    value=\"two\"\n    oninput=${(e) => radioShared = e.target.value}\n    ${(e) => radioShared === e.target.value ? 'checked' : ''}\n/>\n`;\n\n// deno-fmt-ignore\nconst classComponent = () => html`\n<div class=${() => active ? 'default class-color' : 'default'}>Look at my class</div>\n<button onclick=${() => active = !active}>Toggle Class</button>\n`;\n\n// deno-fmt-ignore\nconst styleComponent = () => html`\n<div style=${() => `color: ${color}`}>Look at my style</div>\n<button onclick=${() => color = Color()}>Change Color</button>\n`;\n\n// deno-fmt-ignore\nconst mapComponent = () => html`\n<ul>${fruits.map((f) => html`\n    <li>${() => f}</li>\n`)}</ul>\n`;\n\n// deno-fmt-ignore\nconst fruitsComponent = () => html`\n<div>${() => fruit}</div>\n<select value=${() => fruit} oninput=${(e) => fruit = e.target.value}>\n    ${fruits.map((f) => html`\n        <option value=${() => f}>${() => f}</option>\n    `)}\n</select>\n`;\n\n// deno-fmt-ignore\nconst carsComponent = () => html`\n<div>${() => carsSelected}</div>\n<select value=${()=> carsSelected} oninput=${(e) => carsSelected = Array.from<HTMLOptionElement>(e.target.selectedOptions).map(o => o.value)} multiple>\n    ${cars.map(c => html`\n        <option value=${c}>${c}</option>\n    `)}\n</select>\n`;\n\n// deno-fmt-ignore\nconst selectBooleanComponent = () => html`\n<div>${() => boolean}</div>\n<select value=${() => boolean} oninput=${e => boolean = JSON.parse(e.target.value)}>\n    <option value=\"true\">yes</option>\n    <option value=\"false\">no</option>\n</select>\n`;\n\n// deno-fmt-ignore\nconst selectNumberComponent = () => html`\n<div>${() => number}</div>\n<select value=${() => number} oninput=${e => number = JSON.parse(e.target.value)}>\n    <option value=\"0\">zero</option>\n    <option value=\"1\">one</option>\n    <option value=\"2\">two</option>\n</select>\n`;\n\n// const connected = () => { console.log('connected'); };\n// const disconnected = () => { console.log('disconnected'); };\n\nexport default html`\n\n    <style>\n        .default {\n            border: solid 5px transparent;\n        }\n        .class-color {\n            border-color: var(--accent);\n        }\n    </style>\n\n    <section id=\"input\">\n        <h3>Input</h3>\n        <p>Attributes starting with <code>on</code> will be removed and will set/remove an EventListener.</p>\n        <pre id=\"inputCode\">${highlight(inputComponent.toString())}</pre>\n        <pre id=\"inputComponent\">${inputComponent()}</pre>\n        <pre id=\"inputSource\">${() => highlight(inputComponent()())}</pre>\n    </section>\n\n    <section id=\"check\">\n        <h3>Check</h3>\n        <p>Dynamic attributes are allowed which can be used to toggle the attribute.</p>\n        <pre id=\"checkCode\">${highlight(checkComponent.toString())}</pre>\n        <pre id=\"checkComponent\">${checkComponent()}</pre>\n        <pre id=\"checkSource\">${() => highlight(checkComponent()())}</pre>\n    </section>\n\n    <section id=\"radio\">\n        <h3>Radio</h3>\n        <p>Attribute values will be converted to Strings but set the Element property with the original type.</p>\n        <pre id=\"radioCode\">${highlight(radioComponent.toString())}</pre>\n        <pre id=\"radioComponent\">${radioComponent()}</pre>\n        <pre id=\"radioSource\">${() => highlight(radioComponent()())}</pre>\n    </section>\n\n    <section id=\"class\">\n        <h3>Class</h3>\n        <pre id=\"classCode\">${highlight(classComponent.toString())}</pre>\n        <pre id=\"classComponent\">${classComponent()}</pre>\n        <pre id=\"classSource\">${() => highlight(classComponent()())}</pre>\n    </section>\n\n    <section id=\"style\">\n        <h3>Style</h3>\n        <pre id=\"styleCode\">${highlight(styleComponent.toString())}</pre>\n        <pre id=\"styleComponent\">${styleComponent()}</pre>\n        <pre id=\"styleSource\">${() => highlight(styleComponent()())}</pre>\n    </section>\n\n    <section id=\"map\">\n        <h3>Map</h3>\n        <pre id=\"mapCode\">${highlight(mapComponent.toString())}</pre>\n        <pre id=\"mapComponent\">${mapComponent()}</pre>\n        <pre id=\"mapSource\">${() => highlight(mapComponent()())}</pre>\n    </section>\n\n    <section id=\"select\">\n        <h3>Select</h3>\n\n        <pre id=\"fruitsCode\">${highlight(fruitsComponent.toString())}</pre>\n        <pre id=\"fruitsComponent\">${fruitsComponent()}</pre>\n        <pre id=\"fruitsSource\">${() => highlight(fruitsComponent()())}</pre>\n\n        <br>\n        <pre id=\"carsCode\">${highlight(carsComponent.toString())}</pre>\n        <pre id=\"carsComponent\">${carsComponent()}</pre>\n        <pre id=\"carsSource\">${() => highlight(carsComponent()())}</pre>\n\n        <br>\n        <pre id=\"selectBooleanCode\">${highlight(selectBooleanComponent.toString())}</pre>\n        <pre id=\"selectBooleanComponent\">${selectBooleanComponent()}</pre>\n        <pre id=\"selectBooleanSource\">${() => highlight(selectBooleanComponent()())}</pre>\n\n        <br>\n        <pre id=\"selectNumberCode\">${highlight(selectNumberComponent.toString())}</pre>\n        <pre id=\"selectNumberComponent\">${selectNumberComponent()}</pre>\n        <pre id=\"selectNumberSource\">${() => highlight(selectNumberComponent()())}</pre>\n    </section>\n\n`('main');\n\n/*\n\n    <section id=\"dynamic\">\n        <h3>Dynamic</h3>\n        <p>Safe and efficient Dynamic tag/elements and attributes.</p>\n        <pre id=\"dynamicCode\"></pre>\n        <pre id=\"dynamicComponent\">${dynamicComponent()}</pre>\n        <pre id=\"dynamicSource\"></pre>\n    </section>\n\n*/\n", "// deno-fmt-ignore-file\nimport { html, update } from '../source/index.ts';\n\nconst token = () => Math.random().toString(36).substring(2, 5);\nconst length = 500;\n// const length = 1;\n\nconst items = Array.from({ length }, (_, index) => ({ name: token(), id: index }));\n\nconst pause = () => new Promise((resolve) => setTimeout(resolve, 50));\n\nconst rename = async () => {\n    items.forEach((item) => item.name = token());\n    await update();\n    await pause();\n    await rename();\n};\n\nexport default html`\n    <style>\n        .items {\n            box-sizing: border-box;\n            display: flex;\n            flex-wrap: wrap;\n            padding: 0;\n            margin: 0;\n        }\n        .item {\n            display: block;\n            width: 10%;\n            padding: 5px;\n            box-sizing: border-box;\n            border: 1px solid lightgray;\n        }\n    </style>\n    <section onTimeout=${() => rename()}>\n        <h1>Performance</h1>\n        <div class=\"items\">\n            ${() => items.map((item) => html`\n                <span class=\"item\">${() => item.name}</span>\n            `)}\n        </div>\n    </section>\n`('main');\n                // <span class=\"item\">${() => item.name}</span>\n", "import { html } from '../source/index.ts';\n\nexport default html`\n    <section>\n        <h1>404</h1>\n        <h2>Page Not Found</h2>\n    </section>\n`('main');\n", "// import root from './root.js';\n// import guide from './guide.js';\n\n// const main = document.querySelector('main');\n\nconst pathname = location.pathname.toLowerCase().replace('/element/', '').replace(/^\\/|\\/+$/g, '');\n\nswitch (pathname) {\n    case '':\n        await import('./root.ts');\n        break;\n    case 'guide':\n        await import('./guide.ts');\n        break;\n    case 'performance':\n        await import('./performance.ts');\n        break;\n    default:\n        await import('./all.ts');\n}\n\n// router('/', main, () => import('./root.js'));\n// router('/guide', main, () => import('./guide.js'));\n// router('/guide/', main, () => import('./guide.js'));\n// router('/security', main, () => import('./security.js'));\n// router('/security/', main, () => import('./security.js'));\n// router('/*', main, () => import('./all.js'));\n// location.replace(location.href);\n"],
  "mappings": "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",
  "names": ["element", "data", "element", "source", "element", "source", "source", "source", "isOnce", "text", "element", "length", "color"]
}
