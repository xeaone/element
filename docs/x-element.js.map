{
  "version": 3,
  "sources": ["../source/global.ts", "../source/tools.ts", "../source/reference.ts", "../source/attribute-name.ts", "../source/display.ts", "../source/update.ts", "../source/event.ts", "../source/attribute-value.ts", "../source/text.ts", "../source/action.ts", "../source/bind.ts", "../source/initialize.ts", "../source/dash.ts", "../source/define.ts", "../source/style.ts", "../source/index.ts"],
  "sourcesContent": ["import { Global } from './types';\n\nexport const global: Global = (globalThis as any).XGLOBAL ?? ((globalThis as any).XGLOBAL = Object.freeze({\n    // QueueNext: undefined,\n    // QueueCurrent: undefined,\n\n    Bound: new WeakMap(),\n    BindersCache: new Set(),\n\n    // GlobalBinders: new Set(),\n    // LocalBinders: new Set(),\n    // QueueBinders: new Set(),\n\n    // VirtualCache: new WeakMap(),\n\n    TemplatesCache: new WeakMap(),\n    ContainersCache: new WeakMap(),\n\n    MarkSymbol: Symbol('mark'),\n    ViewSymbol: Symbol('view'),\n\n    TemplateSymbol: Symbol('template'),\n    VariablesSymbol: Symbol('variables'),\n}));\n\nexport const {\n    // QueueNext,\n    // QueueCurrent,\n\n    BindersCache,\n\n    // GlobalBinders,\n    // LocalBinders,\n    // QueueBinders,\n\n    // VirtualCache,\n\n    TemplatesCache,\n    ContainersCache,\n\n    MarkSymbol,\n    ViewSymbol,\n    TemplateSymbol,\n    VariablesSymbol,\n} = global;\n", "\n// globalThis.NodeFilter = globalThis.NodeFilter || {\n//     FILTER_ACCEPT: 1,\n//     FILTER_REJECT: 2,\n//     FILTER_SKIP: 3,\n//     SHOW_ALL: 0xFFFFFFFF,\n//     SHOW_ELEMENT: 0x1,\n//     SHOW_ATTRIBUTE: 0x2,\n//     SHOW_TEXT: 0x4,\n//     SHOW_CDATA_SECTION: 0x8,\n//     SHOW_ENTITY_REFERENCE: 0x10,\n//     SHOW_ENTITY: 0x20,\n//     SHOW_PROCESSING_INSTRUCTION: 0x40,\n//     SHOW_COMMENT: 0x80,\n//     SHOW_DOCUMENT: 0x100,\n//     SHOW_DOCUMENT_TYPE: 0x200,\n//     SHOW_DOCUMENT_FRAGMENT: 0x400,\n//     SHOW_NOTATION: 0x800,\n// };\n\nexport const {\n    SHOW_TEXT,\n    SHOW_ELEMENT,\n} = NodeFilter;\n\nexport const {\n    TEXT_NODE,\n    COMMENT_NODE,\n    ELEMENT_NODE,\n    ATTRIBUTE_NODE,\n    DOCUMENT_FRAGMENT_NODE,\n} = Node;\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\n// https://www.w3.org/TR/REC-html40/index/attributes.html\nconst patternLink = new RegExp(\n    [\n        '^[.@$]?(',\n        [\n            'src',\n            'href',\n            'data',\n            'action',\n            'srcdoc',\n            'xlink:href',\n            'cite',\n            'formaction',\n            'ping',\n            'poster',\n            'background',\n            'classid',\n            'codebase',\n            'longdesc',\n            'profile',\n            'usemap',\n            'icon',\n            'manifest',\n            'archive',\n        ].join('|'),\n        ')',\n    ].join(''),\n    'i',\n);\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\nconst patternBool = new RegExp(\n    [\n        '^[.@$]?(',\n        [\n            'hidden',\n            'allowfullscreen',\n            'async',\n            'autofocus',\n            'autoplay',\n            'checked',\n            'controls',\n            'default',\n            'defer',\n            'disabled',\n            'formnovalidate',\n            'inert',\n            'ismap',\n            'itemscope',\n            'loop',\n            'multiple',\n            'muted',\n            'nomodule',\n            'novalidate',\n            'open',\n            'playsinline',\n            'readonly',\n            'required',\n            'reversed',\n            'selected',\n        ].join('|'),\n        ')',\n    ].join(''),\n    'i',\n);\n\nconst patternAnimation = /^[.@$]?onanimation$/i;\nconst patternTimeout = /^[.@$]?ontimeout$/i;\nconst patternOnce = /^[.@$]?ononce$/i;\nconst patternValue = /^[.@$]?value$/i;\nconst patternOn = /^[.@$]?on/i;\nconst patternMarker = /^x-[0-9]{10}-x$/i;\n// const safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\nconst safePattern = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\n\nexport const isLink = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternLink.test(data) : false;\n};\n\nexport const isBool = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternBool.test(data) : false;\n};\n\nexport const isIterable = function (data: any): boolean {\n    return data && typeof data !== 'string' && typeof data[Symbol.iterator] === 'function';\n};\n\nexport const isAnimation = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternAnimation.test(data) : false;\n};\n\nexport const isOnce = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternOnce.test(data) : false;\n};\n\nexport const isTimeout = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternTimeout.test(data) : false;\n};\n\nexport const isValue = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternValue.test(data) : false;\n};\n\nexport const hasOn = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternOn.test(data) : false;\n};\n\nexport const isMarker = function (data: string): boolean {\n    return data && typeof data === 'string' ? patternMarker.test(data) : false;\n};\n\nexport const matchMarker = function (data: string, marker: string): boolean {\n    return data && marker &&\n            typeof data === 'string' &&\n            typeof marker === 'string'\n        ? data.toLowerCase() === marker.toLowerCase()\n        : false;\n};\n\nexport const hasMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ? data.indexOf(marker) !== -1 : false;\n};\n\nexport const sliceOn = function (data: string): string {\n    return data && typeof data === 'string' ? data.replace(patternOn, '') : '';\n};\n\nexport const isConnected = function (node: Node): boolean {\n    if (node.nodeType === Node.ATTRIBUTE_NODE) {\n        return node.parentNode?.isConnected ?? false;\n    } else {\n        return node.isConnected;\n    }\n    // return (\n    //     !node.ownerDocument ||\n    //     !(\n    //       node.ownerDocument.compareDocumentPosition(node) &\n    //       node.DOCUMENT_POSITION_DISCONNECTED\n    //     )\n    // );\n};\n\n// export const includes = function (item: string | Array<any>, search: any) {\n//     return item.indexOf(search) !== -1;\n// };\n\nexport const mark = function (): string {\n    return `x-${`${Math.floor(Math.random() * Date.now())}`.slice(0, 10)}-x`;\n};\n\nexport const dangerousLink = function (data: string): boolean {\n    if (data === '') return false;\n    if (typeof data !== 'string') return false;\n    return safePattern.test(data) ? false : true;\n};\n\n/**\n *  DOM mod methods\n */\n\nexport const removeBetween = function (start: Node, end: Node) {\n    let node = end.previousSibling;\n    while (node && node !== start) {\n        node.parentNode?.removeChild(node);\n        node = end.previousSibling;\n    }\n};\n\nexport const removeNode = function (node: Node): void {\n    (node.parentNode as Node).removeChild(node);\n};\n\nexport const beforeNode = function (node: Node | string, child: Node): void {\n    if (!(node instanceof Node)) node = (child.ownerDocument as Document).createTextNode(`${node}`);\n    (child.parentNode as Node).insertBefore(node, child);\n};\n\nexport const afterNode = function (node: Node | string, child: Node): void {\n    if (!(node instanceof Node)) node = (child.ownerDocument as Document).createTextNode(`${node}`);\n    (child.parentNode as Node).insertBefore(node, child.nextSibling);\n};\n\nexport const replaceNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).replaceChild(node, child);\n};\n\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n    }\n\n    for (const node of nodes) {\n        element.appendChild(\n            typeof node === 'string' ? (element.ownerDocument as Document).createTextNode(node) : node,\n        );\n    }\n};\n\n/**\n * Attr DOM\n */\n\nexport const addAttribute = function (owner: Element, attribute: Attr): Attr {\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const createAttribute = function (owner: Element, name: string, value?: string): Attr {\n    const attribute = owner.ownerDocument.createAttribute(name);\n    attribute.value = value ?? '';\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const removeAttribute = function (node: Attr): Attr {\n    return (node.ownerElement as Element).removeAttributeNode(node);\n};\n\n/**\n * Node methods\n */\n\nexport const isText = function (node: Node | null): boolean {\n    return node?.nodeType === TEXT_NODE;\n};\n\nexport const isAttribute = function (node: Node | null): boolean {\n    return node?.nodeType === ATTRIBUTE_NODE;\n};\n\nexport const isElement = function (node: Node | null): boolean {\n    return node?.nodeType === ELEMENT_NODE;\n};\n\nexport const isComment = function (node: Node | null): boolean {\n    return node?.nodeType === COMMENT_NODE;\n};\n", "import { ReferenceType } from './types';\n\n// if (!('WeakRef' in globalThis)) {\n//     globalThis['WeakRef'] = (function () {\n//         const wm = new WeakMap();\n//         const WeakRef = function (target) {\n//             wm.set(this, target);\n//         };\n//         WeakRef.prototype.deref = function () {\n//             return wm.get(this);\n//         };\n//         return WeakRef as any;\n//     })();\n// }\n\nexport const Reference = function <T>(data: T): ReferenceType<T> {\n    return {\n        data: data instanceof Node ? new WeakRef(data) : data,\n        get: function <T>(): T | undefined {\n            if (this.data instanceof WeakRef) {\n                return this.data.deref();\n            } else {\n                return this.data;\n            }\n        },\n        set: function <T>(data: T): T | undefined {\n            if (data instanceof Node) {\n                this.data = new WeakRef(data);\n                return data;\n            } else {\n                this.data = data;\n                return data;\n            }\n        },\n    };\n};\n", "import { hasOn, isBool, isLink, isValue, sliceOn } from './tools';\nimport { Binder } from './types';\n\nexport const attributeName = function (element: Element, binder: Binder, source: any, target: any): void {\n    source = source?.toLowerCase() ?? '';\n    target = target?.toLowerCase() ?? '';\n\n    // console.log('binder:', binder, 'source:', source, 'target:', target);\n\n    if (source === target) {\n        return;\n    }\n\n    if (hasOn(source)) {\n        if (typeof binder.value === 'function') {\n            element.removeEventListener(sliceOn(source), binder.value, true);\n        }\n    } else if (isValue(source)) {\n        element.removeAttribute(source);\n        Reflect.set(element, source, null);\n    } else if (isBool(source)) {\n        element.removeAttribute(source);\n        Reflect.set(element, source, false);\n    } else if (isLink(source)) {\n        element.removeAttribute(source);\n        Reflect.deleteProperty(element, source);\n    } else if (source) {\n        element.removeAttribute(source);\n        Reflect.deleteProperty(element, source);\n    }\n\n    if (hasOn(target)) {\n        return;\n    } else if (isBool(target)) {\n        binder.value = '';\n        element.setAttribute(target, '');\n        Reflect.set(element, target, true);\n    } else if (target) {\n        element.setAttribute(target, '');\n        Reflect.set(element, target, null);\n    }\n\n    binder.name = target || '';\n};\n", "export const display = function (data: any): string {\n    switch (`${data}`) {\n        case 'NaN':\n            return '';\n        case 'null':\n            return '';\n        case 'undefined':\n            return '';\n    }\n\n    switch (typeof data) {\n        case 'string':\n            return data;\n        case 'number':\n            return `${data}`;\n        case 'bigint':\n            return `${data}`;\n        case 'boolean':\n            return `${data}`;\n        case 'symbol':\n            return String(data);\n        case 'object':\n            return JSON.stringify(data);\n    }\n\n    throw new Error('XElement - display type not handled');\n};\n", "import { BindersCache } from './global';\nimport { action } from './action';\n\nlet Next: Promise<void> | undefined;\nlet Current: Promise<void> | undefined;\n\nexport const next = async function (): Promise<void> {\n    console.log('next');\n    await Current;\n    await new Promise((resolve) => {\n        queueMicrotask(async () => {\n            Next = undefined;\n            await update();\n            resolve(undefined);\n        });\n    });\n};\n\nexport const update = async function (): Promise<void> {\n    console.log('update');\n    if (Current) {\n        if (Next) {\n            await Next;\n        } else {\n            Next = next();\n            await Next;\n        }\n    } else {\n        Current = new Promise((resolve) => {\n            queueMicrotask(async () => {\n                const binders = BindersCache.values();\n\n                for (const binder of binders) {\n                    try {\n                        await action(binder);\n                    } catch (error) {\n                        console.error(error);\n                    }\n                }\n\n                Current = undefined;\n\n                resolve();\n            });\n        });\n\n        await Current;\n    }\n};\n\nexport const updateAllSync = function () {\n    const binders = BindersCache.values();\n\n    for (const binder of binders) {\n        try {\n            action(binder);\n        } catch (error) {\n            console.error(error);\n        }\n    }\n\n}\n\n// const stack: Binder[] = [];\n// export const update = async function (binders?: Binder[]): Promise<void> {\n//     if (binders && binders.length) {\n//         stack.push(...binders);\n//     }\n\n//     if (Current) {\n//         await Current;\n//     } else {\n//         Current = new Promise((resolve) => {\n//             queueMicrotask(async () => {\n//                 let binder: Binder | undefined = stack?.shift();\n\n//                 while (binder) {\n//                     try {\n//                         await action(binder);\n//                     } catch (error) {\n//                         console.error(error);\n//                     }\n\n//                     binder = stack?.shift();\n//                 }\n\n//                 Current = undefined;\n\n//                 resolve();\n//             });\n//         });\n\n//         await Current;\n//     }\n// };\n", "import { Binder } from './types';\n// import { update } from './update';\n\nexport const event = function (binder: Binder) {\n    return {\n        get target() {\n            return binder?.node;\n        },\n        // update,\n        query(selector: string): Element | null {\n            return (binder?.node?.getRootNode() as Element)?.querySelector(selector);\n        },\n    };\n};\n", "import { dangerousLink, hasOn, isBool, isLink, isOnce, isValue, sliceOn } from './tools';\nimport { display } from './display';\nimport { update } from './update';\nimport { Binder } from './types';\nimport { event } from './event';\nimport { isTimeout } from './tools';\n\nconst isRadioChecked = function (element: Element) {\n    if (element.nodeName === 'INPUT' && (element as HTMLInputElement).type === 'radio') {\n        const radios = element.ownerDocument.querySelectorAll<HTMLInputElement>(`input[name=\"${(element as HTMLInputElement).name}\"]`);\n        for (const radio of radios) {\n            if (radio.checked) {\n                return radio.checked;\n            }\n        }\n    }\n\n    return false;\n};\n\nexport const attributeValue = function (element: Element, binder: Binder, source: any, target: any): void {\n    if (source === target) {\n        return;\n    }\n\n    if (!binder.name) {\n        console.warn('attribute binder name required');\n        return;\n    }\n\n    if (isValue(binder.name)) {\n        if (element.nodeName === 'SELECT') {\n            const options = (element as HTMLSelectElement).options as HTMLOptionsCollection;\n            const array = Array.isArray(target);\n            for (const option of options) {\n                option.selected = array ? target.includes(option.value) : `${target}` === option.value;\n            }\n        } else {\n            binder.value = display(target);\n            element.setAttribute(binder.name, binder.value);\n            Reflect.set(element, binder.name, binder.value);\n        }\n    } else if (isLink(binder.name)) {\n        binder.value = encodeURI(target);\n\n        if (dangerousLink(binder.value)) {\n            element.removeAttribute(binder.name);\n            console.warn(`XElement - attribute name \"${binder.name}\" and value \"${binder.value}\" not allowed`);\n            return;\n        }\n\n        element.setAttribute(binder.name, binder.value);\n        Reflect.set(element, binder.name, binder.value);\n    } else if (isBool(binder.name)) {\n        const bool = !!target;\n\n        if (bool) {\n            element.setAttribute(binder.name, '');\n        } else {\n            element.removeAttribute(binder.name);\n        }\n\n        Reflect.set(element, binder.name, bool);\n    } else if (hasOn(binder.name)) {\n        // handle onanimation ontimeout\n\n        if (element.hasAttribute(binder.name)) {\n            element.removeAttribute(binder.name);\n        }\n\n        if (typeof binder.value === 'function') {\n            element.removeEventListener(\n                sliceOn(binder.name),\n                binder.value,\n                source?.[1] ?? true,\n            );\n        }\n\n        const method = typeof target === 'function' ? target : target?.[0];\n\n        if (typeof method !== 'function') {\n            return console.warn(`XElement - attribute name \"${binder.name}\" expected a function`);\n        }\n\n        let oldResult: any;\n        binder.value = function () {\n            if (element.nodeName === 'INPUT' && (element as HTMLInputElement).type === 'radio') {\n                const radios = element.ownerDocument.querySelectorAll<HTMLInputElement>(`input[name=\"${(element as HTMLInputElement).name}\"]`);\n                for (const radio of radios) {\n                    if (radio.checked) {\n                        oldResult = radio.checked;\n                    }\n                }\n            }\n\n            const newResult = method.call(this, event(binder));\n\n            if (newResult !== oldResult) {\n                oldResult = newResult;\n                update();\n            }\n\n            return newResult;\n        };\n\n        if (isOnce(binder.name)) {\n            binder.value();\n        } else if (isTimeout(binder.name)) {\n            setTimeout(binder.value, target?.[1]);\n        } else {\n            element.addEventListener(sliceOn(binder.name), binder.value, target?.[1] ?? true);\n        }\n    } else {\n        binder.value = target;\n        element.setAttribute(binder.name, binder.value);\n        Reflect.set(element, binder.name, binder.value);\n    }\n};\n\n// const attribute = function (node: Attr, binder: Binder, source: any, target: any) {\n//     const name = node.name;\n//     const value = node.value;\n\n//     if (hasOn(name)) {\n\n//         if (isAnimation(name)) {\n//             // const variable = binder.result;\n//             const isArray = Array.isArray(binder.result);\n//             const method = isArray ? binder.result[ 0 ] : binder.result;\n//             const handle = async () => {\n//                 if (binder.owner?.isConnected) {\n//                     const result = method();\n//                     if (binder.result === result) {\n//                         requestAnimationFrame(handle);\n//                     } else {\n//                         binder.result = result;\n//                         await update();\n//                         requestAnimationFrame(handle);\n//                     }\n//                 } else {\n//                     requestAnimationFrame(handle);\n//                 }\n//             };\n//             requestAnimationFrame(handle);\n//         } else if (isTimeout(name)) {\n//             // const variable = binder.variable;\n//             // const isArray = Array.isArray(variable);\n//             // const method = isArray ? variable[ 0 ] : variable;\n//             // const time = isArray ? variable[ 1 ] : undefined;\n\n//             const isArray = Array.isArray(binder.result);\n//             const method = isArray ? binder.result[ 0 ] : binder.result;\n//             const time = isArray ? binder.result[ 1 ] : undefined;\n//             const handle = async () => {\n//                 const result = method();\n//                 if (binder.result === result) {\n//                     return;\n//                 } else {\n//                     binder.result = result;\n//                     await update();\n//                 }\n//             };\n//             setTimeout(handle, time);\n//         } else {\n//             const owner = binder.owner;\n//             if (owner) {\n//                 const eventName = name.substring(2);\n//                 const isArray = Array.isArray(result);\n//                 const [ method, options ] = isArray ? result : [ result, undefined ];\n//                 if (typeof method === 'function') {\n//                     // owner.removeEventListener(eventName, result);\n//                     owner.addEventListener(eventName, async function (event) {\n//                         const returned = method(event);\n//                         if (binder.meta.returned !== returned) {\n//                             binder.meta.returned = returned;\n//                             await update();\n//                         }\n//                     }, options);\n//                     intersectionObserver.observe(owner);\n//                 } else {\n//                     console.error(`${name} requiures function or array with function`);\n//                 }\n//             }\n//         }\n\n//         const owner = binder.owner;\n//         if (owner) {\n//             owner.removeAttributeNode(node);\n//         }\n\n//     // } else if (isMarker(name)) {\n//     } else if (value === '') {\n//         if (name === result) {\n//             if (!binder.owner?.hasAttribute(result)) {\n//                 addAttribute(binder.owner as Element, node);\n//                 Reflect.set(binder.owner as Element, result, true);\n//             }\n//         } else {\n//             if (result) {\n//                 removeAttribute(node);\n//                 binder.replace(createAttribute(binder.owner as Element, result));\n//                 Reflect.set(binder.owner as Element, result, true);\n//             } else {\n//                 removeAttribute(node);\n//                 Reflect.set(binder.owner as Element, result, false);\n//             }\n//         }\n//     } else if (result instanceof Attr) {\n\n//     } else {\n//         node.value = result;\n//     }\n// };\n", "import { afterNode, beforeNode, isIterable, removeBetween, removeNode, replaceNode } from './tools';\nimport { MarkSymbol, ViewSymbol } from './global';\nimport { display } from './display';\nimport { Binder } from './types';\n\nconst iterableDisplay = function (data: any): Node | string {\n    return data?.[ViewSymbol] ? data() : data instanceof Node ? data : display(data);\n};\n\nexport const text = function (node: Text, binder: Binder, source: any, target: any): void {\n    if (target === null || target === undefined) {\n        if (node.textContent !== '') {\n            node.textContent = '';\n        }\n    } else if (target?.[ViewSymbol]) {\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        removeBetween(binder.start, binder.end);\n        beforeNode(target(), binder.end);\n    } else if (target instanceof DocumentFragment) {\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        removeBetween(binder.start, binder.end);\n        beforeNode(target, binder.end);\n    } else if (isIterable(target)) {\n        // console.log(target);\n\n        if (binder.length === undefined) {\n            binder.length = 0;\n        }\n\n        if (!binder.results) {\n            binder.results = [];\n        }\n\n        if (!binder.markers) {\n            binder.markers = [];\n        }\n\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        const oldLength = binder.length;\n        const newLength = target.length;\n        const commonLength = Math.min(oldLength, newLength);\n\n        // todo: make this more efficient\n        for (let index = 0; index < commonLength; index++) {\n            if (\n                target[index] === binder.results[index] ||\n                target[index]?.[ViewSymbol] && binder.results[index]?.[ViewSymbol] && target[index]?.[MarkSymbol] === binder.results[index]?.[MarkSymbol]\n            ) continue;\n\n            const marker = binder.markers[index];\n            const last = binder.markers[index + 1] ?? binder.end;\n            while (last.previousSibling && last.previousSibling !== marker) {\n                removeNode(last.previousSibling);\n            }\n\n            const child = iterableDisplay(target[index]);\n            afterNode(child, marker);\n            console.log(binder.results[index], target[index], child, marker);\n\n            binder.results[index] = target[index];\n        }\n\n        if (oldLength < newLength) {\n            while (binder.length !== target.length) {\n                const marker = document.createTextNode('');\n                const child = iterableDisplay(target[binder.length]);\n\n                binder.markers.push(marker);\n                binder.results.push(target[binder.length]);\n\n                beforeNode(marker, binder.end);\n                beforeNode(child, binder.end);\n                binder.length++;\n            }\n        } else if (oldLength > newLength) {\n            // const last = binder.markers[ target.length - 1 ];\n\n            // while (binder.length !== target.length) {\n            //     const previous = binder.end.previousSibling;\n            //     if (previous === last) break;\n            //     removeNode(previous as Node);\n            // }\n\n            const marker = binder.markers[target.length - 1];\n            const last = binder.end;\n            while (last.previousSibling && last.previousSibling !== marker) {\n                removeNode(last.previousSibling);\n            }\n\n            binder.length = target.length;\n            binder.results.length = target.length;\n            binder.markers.length = target.length;\n        }\n    } else if (target instanceof Node) {\n        replaceNode(target, node);\n    } else {\n        if (node.textContent === `${target}`) {\n            return;\n        } else {\n            node.textContent = `${target}`;\n        }\n    }\n};\n", "import { attributeName } from './attribute-name';\nimport { attributeValue } from './attribute-value';\nimport { hasOn, isConnected } from './tools';\nimport { ViewSymbol } from './global';\nimport { Binder } from './types';\nimport { event } from './event';\nimport { text } from './text';\nimport { MarkSymbol } from './global';\n\n/**\n * @module Action\n * @todo need to handle element name changes\n * @todo need to handle attribute name changes\n * @todo\n */\n\nconst comment = function (node: Comment, data: any, source: any, target: any): void {\n    console.warn('comment action not implemented');\n};\n\nconst element = function (node: Element, data: any, source: any, target: any): void {\n    console.warn('element action not implemented');\n};\n\nexport const action = function (binder: Binder) {\n    const node = binder.node;\n\n    if (!node) {\n        return;\n    }\n\n    // this optimization could prevent disconnected nodes from being render when re/connected\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n    if (!isConnected(node) && binder.isInitialized) {\n        return;\n    }\n\n    const variable = binder.variable;\n    const isFunction = typeof variable === 'function';\n    const isInstance = isFunction && (variable as any)[ViewSymbol];\n    const isOnce = binder.type === 3 && hasOn(binder.name);\n    const isReactive = !isInstance && !isOnce && isFunction;\n\n    if (isOnce || isInstance || !isFunction) {\n        binder.remove();\n    }\n\n    const target = isReactive ? variable(event(binder)) : isInstance ? variable() : variable;\n\n    const source = binder.source;\n    if (\n        'source' in binder &&\n        (\n            source === target ||\n            source?.[ViewSymbol] && target?.[ViewSymbol] && source?.[MarkSymbol] === target?.[MarkSymbol]\n        )\n    ) {\n        return;\n    }\n\n    if (binder.type === 1) {\n        element(node as Element, binder, source, target);\n    } else if (binder.type === 2) {\n        attributeName(node as Element, binder, source, target);\n    } else if (binder.type === 3) {\n        attributeValue(node as Element, binder, source, target);\n    } else if (binder.type === 4) {\n        text(node as Text, binder, source, target);\n    } else {\n        throw new Error('instruction type not valid');\n    }\n\n    binder.source = target;\n    binder.isInitialized = true;\n};\n", "import { Binder, BinderType, ReferenceType, Variables } from './types';\nimport { BindersCache } from './global';\n// import { update } from './update';\n// import { action } from './action';\n\n// const ro = new ResizeObserver(function (entries) {\n//     console.log(arguments);\n//     // for (const entry of entries) {\n//     //     const { target } = entry;\n//     //     if (target.isConnected) {\n//     //         const childBinder = Bound.get(target);\n//     //         const parentBinder = Bound.get(target.parentElement);\n//     //         console.log(childBinder, parentBinder, childBinder.value, parentBinder.value);\n//     //         if (childBinder && parentBinder && childBinder.value === parentBinder.value) {\n//     //             target.selected = true;\n//     //         }\n//     //         ro.unobserve(target);\n//     //     }\n//     // }\n// });\n\n// const observed: WeakMap<Element, Array<Binder>> = new WeakMap();\n// const io = new IntersectionObserver(async (entries) => {\n//     for (const entry of entries) {\n//         const { target } = entry;\n//         // if (target.isConnected) {\n//         // } else {\n//         //     console.log(target.isConnected, target);\n//         // }\n//         const binders = observed.get(target) as Binder[];\n\n//         for (const binder of binders) {\n//             try {\n//                 await action(binder);\n//             } catch (error) {\n//                 console.error(error);\n//             }\n//         }\n\n//     }\n// }, {\n//     threshold: 1,\n//     // rootMargin: '100000%',\n//     root: document.documentElement,\n// });\n\nexport const bind = function (\n    type: BinderType,\n    index: number,\n    variables: Variables,\n    referenceNode: ReferenceType<Node>,\n    referenceName?: ReferenceType<any>,\n    referenceValue?: ReferenceType<any>,\n) {\n    const binder: Binder = {\n        type,\n\n        // index,\n        // variables,\n        isInitialized: false,\n\n        get variable() {\n            return variables[index];\n        },\n\n        set variable(data: any) {\n            variables[index] = data;\n        },\n\n        get node() {\n            const node = referenceNode.get();\n            if (node) {\n                return node;\n            } else {\n                BindersCache.delete(this);\n                return undefined;\n            }\n        },\n\n        get name() {\n            return (referenceName as ReferenceType<any>).get();\n        },\n\n        set name(name: string) {\n            (referenceName as ReferenceType<any>).set(name);\n        },\n\n        get value() {\n            return (referenceValue as ReferenceType<any>).get();\n        },\n\n        set value(value: string) {\n            (referenceValue as ReferenceType<any>).set(value);\n        },\n\n        remove() {\n            BindersCache.delete(this);\n        },\n\n        add() {\n            BindersCache.add(this);\n        },\n    };\n\n    // const node = binder.node;\n    // const parent = node?.parentElement;\n\n    // if (node instanceof Element) {\n    //     const binders = observed.get(node);\n    //     if (binders) {\n    //         binders.push(binder);\n    //     } else {\n    //         io.observe(node);\n    //         observed.set(node, [binder]);\n    //     }\n    // } else if (parent instanceof Element) {\n    //     if (!document.contains(parent)) {\n    //         console.log(parent);\n    //     }\n\n    //     const binders = observed.get(parent);\n    //     if (binders) {\n    //         binders.push(binder);\n    //     } else {\n    //         io.observe(parent);\n    //         observed.set(parent, [binder]);\n    //     }\n    // } else {\n    //     // binder.add();\n    //     console.warn('top level reactive text bindings');\n    // }\n\n    binder.add();\n\n    return binder;\n};\n", "import { dangerousLink, ELEMENT_NODE, hasMarker, hasOn, isLink, matchMarker, replaceChildren, SHOW_ELEMENT, SHOW_TEXT, TEXT_NODE } from './tools';\nimport { Binder, Container, Marker, ReferenceType, Template, Variables } from './types';\nimport { ContainersCache } from './global';\nimport { Reference } from './reference';\nimport { action } from './action';\n// import { update } from './update';\nimport { bind } from './bind';\n\nconst FILTER = SHOW_ELEMENT + SHOW_TEXT;\n\nexport const initialize = function (\n    template: Template,\n    variables: Variables,\n    marker: Marker,\n    container?: Container,\n): Element | ShadowRoot | DocumentFragment {\n    if (typeof container === 'string') {\n        const selection = document.querySelector(container);\n        if (!selection) throw new Error('query not found');\n        const cache = ContainersCache.get(selection);\n        if (cache && cache === template) {\n            // update();\n            return selection;\n        } else {\n            ContainersCache.set(selection, template);\n        }\n    } else if (container instanceof Element || container instanceof ShadowRoot) {\n        const cache = ContainersCache.get(container);\n        if (cache && cache === template) {\n            // update();\n            return container;\n        } else {\n            ContainersCache.set(container, template);\n        }\n    }\n\n    const binders: Binder[] = [];\n    const fragment = template.content.cloneNode(true) as DocumentFragment;\n    const walker = document.createTreeWalker(fragment, FILTER, null);\n\n    let node: Node | null;\n    let index = 0;\n\n    while (walker.nextNode()) {\n        node = walker.currentNode;\n        const type = node.nodeType;\n\n        if (type === TEXT_NODE) {\n            let text = node as Text;\n\n            const startIndex = text.nodeValue?.indexOf(marker) ?? -1;\n            if (startIndex === -1) continue;\n\n            if (startIndex !== 0) {\n                text.splitText(startIndex);\n                node = walker.nextNode() as Node | null;\n                text = node as Text;\n            }\n\n            const endIndex = marker.length;\n            if (endIndex !== text.nodeValue?.length) {\n                text.splitText(endIndex);\n            }\n\n            const referenceNode = Reference<Node>(text);\n            const binder = bind(4, index++, variables, referenceNode);\n            binders.unshift(binder);\n            // action(binder);\n        } else if (type === ELEMENT_NODE) {\n            const element = node as Element;\n            const tag = element.tagName;\n\n            if (tag === 'STYLE' || tag === 'SCRIPT') {\n                walker.nextSibling();\n            }\n\n            let referenceNode: ReferenceType<Node> | undefined;\n\n            if (matchMarker(tag, marker)) {\n                referenceNode = Reference(node);\n                const binder = bind(1, index++, variables, referenceNode);\n                binders.unshift(binder);\n                // action(binder);\n            }\n\n            const names = element.getAttributeNames();\n            for (const name of names) {\n                const value = element.getAttribute(name) ?? '';\n                const matchMarkerName = matchMarker(name, marker);\n                const hasMarkerValue = hasMarker(value, marker);\n\n                if (matchMarkerName || hasMarkerValue) {\n                    referenceNode = referenceNode ?? Reference(node);\n\n                    if (matchMarkerName && hasMarkerValue) {\n                        const referenceName = Reference<string>('');\n                        const referenceValue = Reference<string>('');\n                        const binderName = bind(2, index++, variables, referenceNode, referenceName, referenceValue);\n                        const binderValue = bind(3, index++, variables, referenceNode, referenceName, referenceValue);\n                        element.removeAttribute(name);\n                        binders.unshift(binderName);\n                        binders.unshift(binderValue);\n                        // action(binderName);\n                        // action(binderValue);\n                    } else if (matchMarkerName) {\n                        const referenceName = Reference<string>('');\n                        const referenceValue = Reference<string>(value);\n                        const binder = bind(2, index++, variables, referenceNode, referenceName, referenceValue);\n                        element.removeAttribute(name);\n                        binders.unshift(binder);\n                        // action(binder);\n                    } else if (hasMarkerValue) {\n                        const referenceName = Reference<string>(name);\n                        const referenceValue = Reference<string>('');\n                        const binder = bind(3, index++, variables, referenceNode, referenceName, referenceValue);\n                        element.removeAttribute(name);\n                        binders.unshift(binder);\n                        // action(binder);\n                    }\n                } else {\n                    if (isLink(name)) {\n                        if (dangerousLink(value)) {\n                            element.removeAttribute(name);\n                            console.warn(`attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (hasOn(name)) {\n                        element.removeAttribute(name);\n                        console.warn(`attribute name \"${name}\" not allowed`);\n                    }\n                }\n            }\n        } else {\n            console.warn(`walker node type \"${type}\" not handled`);\n        }\n    }\n\n    for (const binder of binders) {\n        action(binder);\n    }\n\n    if (typeof container === 'string') {\n        const selection = document.querySelector(container);\n        if (!selection) throw new Error('query not found');\n        replaceChildren(selection, fragment);\n        return selection;\n    } else if (container instanceof Element || container instanceof ShadowRoot) {\n        replaceChildren(container, fragment);\n        return container;\n    } else {\n        return fragment;\n    }\n};\n", "export const dash = function (data: string): string {\n    data = data.replace(/([a-zA-Z])([A-Z])/g, '$1-$2');\n    data = data.toLowerCase();\n    data = data.includes('-') ? data : `x-${data}`;\n    return data;\n};\n", "import { dash } from './dash';\n\n// export const define = function (tag: string, extend?: string) {\n//     return (constructor: CustomElementConstructor, context: ClassDecoratorContext) => {\n//         context.addInitializer(function () {\n//             const $tag = dash(tag);\n//             const $extend = extend;\n//             customElements.define($tag, constructor, { extends: $extend });\n//         });\n//     };\n// };\n\nexport const define = function (tag: string, extend?: string) {\n    return function (constructor: CustomElementConstructor) {\n        const $tag = dash(tag);\n        const $extend = extend;\n        customElements.define($tag, constructor, { extends: $extend });\n    };\n};\n", "const Sheets: WeakMap<CSSStyleSheet, CSSStyleSheet> = new WeakMap();\n\nexport const style = function (instance: HTMLElement) {\n    if (instance.shadowRoot) {\n        const root = document.getRootNode() as Document;\n\n        instance.shadowRoot.adoptedStyleSheets.push(...root.adoptedStyleSheets);\n\n        for (const rootSheet of root.styleSheets) {\n            let cacheSheet: CSSStyleSheet | undefined = Sheets.get(rootSheet);\n\n            if (!cacheSheet) {\n                cacheSheet = new CSSStyleSheet();\n\n                const { cssRules } = rootSheet;\n                for (const { cssText } of cssRules) {\n                    cacheSheet.insertRule(cssText);\n                }\n\n                Sheets.set(rootSheet, cacheSheet);\n            }\n\n            instance.shadowRoot.adoptedStyleSheets.push(cacheSheet);\n        }\n    }\n};\n\n// export const style = function () {\n//     return function (construct: CustomElementConstructor): typeof construct {\n//         return class extends construct {\n//             constructor(...args: any[]) {\n//                 super(...args);\n//                 if (this.shadowRoot) {\n//                     const root = document.getRootNode() as Document;\n//                     this.shadowRoot.adoptedStyleSheets = [...root.styleSheets];\n//                 }\n//             }\n//         };\n//     };\n// };\n", "import { MarkSymbol, TemplatesCache, TemplateSymbol, VariablesSymbol, ViewSymbol } from './global';\nimport { Initialize, Variables } from './types';\nimport { initialize } from './initialize';\nimport { update, updateAllSync } from './update';\nimport { define } from './define';\nimport { mark } from './tools';\n\nimport { style } from './style';\n\n// const query = (node: Node, selector: Selector) => selector.reduce((n, s) => n[ s ], node);\n\nexport { define, style, update, updateAllSync };\n\n// const connectedEvent = new CustomEvent('connected');\n// const disconnectedEvent = new CustomEvent('disconnected');\n// const intersectionElements: WeakMap<Element, { wasConnected: boolean; isIntersecting: boolean }> = new WeakMap();\n// const intersectionObserver = new IntersectionObserver((entries) => {\n//     for (const entry of entries) {\n//         const intersectionElement = intersectionElements.get(entry.target);\n//         if (!intersectionElement) {\n//             intersectionElements.set(entry.target, { wasConnected: false, isIntersecting: entry.isIntersecting });\n//         } else if (entry.target.isConnected === true && intersectionElement.wasConnected === false) {\n//             intersectionElement.wasConnected = true;\n//             intersectionElement.isIntersecting = entry.isIntersecting;\n//             entry.target.dispatchEvent(connectedEvent);\n//         } else if (entry.target.isConnected === false && intersectionElement.wasConnected === true) {\n//             intersectionElement.wasConnected = false;\n//             intersectionElement.isIntersecting = entry.isIntersecting;\n//             entry.target.dispatchEvent(disconnectedEvent);\n//         } else {\n//             //\n//         }\n//     }\n// }, {\n//     threshold: 1,\n//     // rootMargin: '100000%',\n//     root: document.documentElement,\n// });\n\n// const ro = new ResizeObserver((entries) => {\n//     for (const entry of entries) {\n//         const { target } = entry;\n//         if (target.isConnected) {\n//             // console.log(entry);\n//             console.log(target.isConnected, target.parentElement.value, target.value);\n//             if (target?.parentElement?.value === target.value) {\n//                 target.selected = true;\n//             }\n//             ro.unobserve(target);\n//         }\n//     }\n// });\n\n// const io = new IntersectionObserver((entries) => {\n//     for (const entry of entries) {\n//         const { target } = entry;\n//         if (target.isConnected) {\n//             console.log(target.isConnected, target);\n//             // console.log(entry);\n//             // if (target?.parentElement?.value === target.value) {\n//             //     target.selected = true;\n//             // }\n//             // io.unobserve(target);\n//         }\n//     }\n// }, {\n//     threshold: 1,\n//     // rootMargin: '100000%',\n//     root: document.documentElement,\n// });\n\n// const observer = new MutationObserver(function (records) {\n//     console.log(arguments);\n// });\n// observer.observe(document.body, { childList: true, subtree: true });\n\n/**\n * @description\n * @param strings\n * @param variables\n * @returns {DocumentFragment}\n */\n\nexport const html = function (strings: TemplateStringsArray, ...variables: Variables): Initialize {\n    let marker: string;\n    let template: HTMLTemplateElement;\n\n    const cache = TemplatesCache.get(strings);\n\n    if (cache) {\n        marker = cache.marker;\n        template = cache.template;\n    } else {\n        marker = mark();\n\n        let innerHTML = '';\n\n        const length = strings.length - 1;\n        for (let index = 0; index < length; index++) {\n            innerHTML += `${strings[index]}${marker}`;\n        }\n\n        innerHTML += strings[length];\n\n        template = document.createElement('template');\n        template.innerHTML = innerHTML;\n\n        TemplatesCache.set(strings, { template, marker });\n    }\n\n    const meta = {\n        [ViewSymbol]: true,\n        [MarkSymbol]: marker,\n        [TemplateSymbol]: template,\n        [VariablesSymbol]: variables,\n    };\n\n    return Object.assign(initialize.bind(meta, template, variables, marker), meta);\n};\n"],
  "mappings": "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",
  "names": ["global", "BindersCache", "TemplatesCache", "ContainersCache", "MarkSymbol", "ViewSymbol", "TemplateSymbol", "VariablesSymbol", "SHOW_TEXT", "SHOW_ELEMENT", "TEXT_NODE", "COMMENT_NODE", "ELEMENT_NODE", "ATTRIBUTE_NODE", "DOCUMENT_FRAGMENT_NODE", "patternLink", "patternBool", "patternTimeout", "patternOnce", "patternValue", "patternOn", "safePattern", "isLink", "data", "patternLink", "isBool", "patternBool", "isIterable", "isOnce", "data", "patternOnce", "isTimeout", "patternTimeout", "isValue", "patternValue", "hasOn", "patternOn", "matchMarker", "data", "marker", "hasMarker", "sliceOn", "patternOn", "isConnected", "node", "mark", "dangerousLink", "safePattern", "removeBetween", "start", "end", "removeNode", "beforeNode", "child", "afterNode", "replaceNode", "replaceChildren", "element", "nodes", "Reference", "data", "attributeName", "element", "binder", "source", "target", "hasOn", "sliceOn", "isValue", "isBool", "isLink", "display", "data", "Next", "Current", "next", "resolve", "update", "binders", "BindersCache", "binder", "action", "error", "updateAllSync", "event", "binder", "selector", "attributeValue", "element", "binder", "source", "target", "isValue", "options", "array", "option", "display", "isLink", "dangerousLink", "isBool", "bool", "hasOn", "sliceOn", "method", "oldResult", "radios", "radio", "newResult", "event", "update", "isOnce", "isTimeout", "iterableDisplay", "data", "ViewSymbol", "display", "text", "node", "binder", "source", "target", "beforeNode", "removeBetween", "isIterable", "oldLength", "newLength", "commonLength", "index", "MarkSymbol", "marker", "last", "removeNode", "child", "afterNode", "replaceNode", "element", "node", "data", "source", "target", "action", "binder", "isConnected", "variable", "isFunction", "isInstance", "ViewSymbol", "isOnce", "hasOn", "isReactive", "event", "MarkSymbol", "attributeName", "attributeValue", "text", "bind", "type", "index", "variables", "referenceNode", "referenceName", "referenceValue", "binder", "data", "node", "BindersCache", "name", "value", "FILTER", "SHOW_ELEMENT", "SHOW_TEXT", "initialize", "template", "variables", "marker", "container", "selection", "cache", "ContainersCache", "binders", "fragment", "walker", "node", "index", "type", "TEXT_NODE", "text", "startIndex", "endIndex", "referenceNode", "Reference", "binder", "bind", "ELEMENT_NODE", "element", "tag", "matchMarker", "names", "name", "value", "matchMarkerName", "hasMarkerValue", "hasMarker", "referenceName", "referenceValue", "binderName", "binderValue", "isLink", "dangerousLink", "hasOn", "action", "replaceChildren", "dash", "data", "define", "tag", "extend", "constructor", "$tag", "dash", "$extend", "Sheets", "style", "instance", "root", "rootSheet", "cacheSheet", "cssRules", "cssText", "html", "strings", "variables", "marker", "template", "cache", "TemplatesCache", "mark", "innerHTML", "length", "index", "meta", "ViewSymbol", "MarkSymbol", "TemplateSymbol", "VariablesSymbol", "initialize"]
}
