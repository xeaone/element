{
  "version": 3,
  "sources": ["../../source/poly.ts", "../../source/dash.ts", "../../source/upgrade.ts", "../../source/router.ts", "../../source/mark.ts", "../../source/html.ts", "../../source/symbols.ts", "../../source/mount.ts", "../../source/define.ts", "../../source/tools.ts", "../../source/display.ts", "../../source/bind.ts", "../../source/events.ts", "../../source/shadow.ts", "../../source/types.ts", "../../source/index.ts", "index.ts"],
  "sourcesContent": ["\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n\n    }\n\n    if (nodes?.length) {\n        for (const node of nodes) {\n            element.appendChild(\n                typeof node === 'string' ?\n                    (element.ownerDocument as Document).createTextNode(node) :\n                    node\n            );\n        }\n    }\n\n};\n\nconst policy =\n    'trustedTypes' in window ?\n        (window as any).trustedTypes.createPolicy('x-element', { createHTML: (data: any) => data }) :\n        undefined;\n\nexport const createHTML = function (data: string) {\n    if (policy) {\n        return policy.createHTML(data);\n    } else {\n        return data;\n    }\n};\n\nexport const hasOwn = function (object: any, key: any) {\n    return Object.prototype.hasOwnProperty.call(object, key);\n};", "\nexport default function dash (data: string): string {\n    data = data.replace(/([a-zA-Z])([A-Z])/g, '$1-$2');\n    data = data.toLowerCase();\n    data = data.includes('-') ? data : `x-${data}`;\n    return data;\n}\n", "export default (instance: Node) => {\n    if (customElements.upgrade) {\n        customElements.upgrade(instance);\n    }\n}", "import { Route, Handler, Module } from './types';\nimport { replaceChildren } from './poly';\n// import component, { task } from './component';\nimport dash from './dash';\nimport upgrade from './upgrade';\n\nconst alls: Array<Route> = [];\nconst routes: Array<Route> = [];\n\n// const position = function (parent: Element) {\n//     return {\n//         parent: parent?.scrollTop,\n//         body: document?.body?.scrollTop,\n//         documentElement: document?.documentElement?.scrollTop,\n//     };\n// };\n\nconst tick = function (element: Element) {\n    return new Promise(async resolve => {\n        if (element && element) {\n        // if (element && element instanceof component) {\n            // await element[ task ];\n            requestAnimationFrame(() => resolve(undefined));\n        } else {\n            requestAnimationFrame(() => resolve(undefined));\n        }\n    });\n};\n\n// window.addEventListener('popstate', (event) => {\n//     console.log(event);\n// });\n\nconst transition = async function (route: Route) {\n    if (route.instance) {\n        const ready = tick(route.instance);\n        replaceChildren(route.root, route.instance);\n        await ready;\n    } else {\n        const result = await route.handler();\n\n        if ((result as CustomElementConstructor)?.prototype instanceof HTMLElement) {\n            route.construct = result as CustomElementConstructor;\n        } else if (((result as Module)?.default as CustomElementConstructor)?.prototype instanceof HTMLElement) {\n            route.construct = (result as Module).default as CustomElementConstructor;\n        } else {\n            throw new Error('XElement - router handler requires Module or CustomElementConstructor');\n        }\n\n        // if (route.construct.prototype instanceof component) {\n        //     route.instance = await (route.construct as typeof component).create();\n        // } else {\n            route.tag = dash(route.construct.name);\n\n            if (customElements.get(route.tag) !== route.construct) {\n                customElements.define(route.tag, route.construct);\n            }\n\n            route.instance = document.createElement(route.tag);\n            upgrade(route.instance);\n        // }\n\n        const ready = tick(route.instance);\n        replaceChildren(route.root, route.instance);\n        await ready;\n    }\n};\n\nconst navigate = function (event?: any) {\n    if (event && 'canIntercept' in event && event.canIntercept === false) return;\n    if (event && 'canTransition' in event && event.canTransition === false) return;\n\n    const destination = new URL(event?.destination.url ?? location.href);\n    const base = new URL(document.querySelector('base')?.href ?? location.origin);\n\n    base.hash = '';\n    base.search = '';\n    destination.hash = '';\n    destination.search = '';\n\n    const pathname = destination.href.replace(base.href, '/');\n    const transitions: Array<Route> = [];\n\n    // window.history.replaceState(destination.href, JSON.stringify(position(route.root)));\n\n    for (const route of routes) {\n        if (route.path !== pathname) continue;\n        transitions.push(route);\n    }\n\n    for (const all of alls) {\n        let has = false;\n\n        for (const transition of transitions) {\n            if (transition.root === all.root) {\n                has = true;\n                break;\n            }\n        }\n\n        if (has) continue;\n\n        transitions.push(all);\n    }\n\n    if (event?.intercept) {\n        return event.intercept({\n            handler: async () => {\n                await Promise.all(transitions.map((route) => transition(route)));\n            }\n        });\n    } else if (event?.transitionWhile) {\n        return event.transitionWhile(Promise.all(transitions.map((route) => transition(route))));\n    } else {\n        Promise.all(transitions.map((route) => transition(route)));\n    }\n};\n\nconst router = function (path: string, root: Element, handler: Handler) {\n    if (!path) throw new Error('XElement - router path required');\n    if (!handler) throw new Error('XElement - router handler required');\n    if (!root) throw new Error('XElement - router root required');\n\n    if (path === '/*') {\n        for (const all of alls) {\n            if (all.path === path && all.root === root) {\n                throw new Error('XElement - router duplicate path on root');\n            }\n        }\n\n        alls.push({ path, root, handler, });\n    } else {\n        for (const route of routes) {\n            if (route.path === path && route.root === root) {\n                throw new Error('XElement - router duplicate path on root');\n            }\n        }\n\n        routes.push({ path, root, handler, instance: undefined });\n    }\n\n    Reflect.get(window, 'navigation').addEventListener('navigate', navigate);\n};\n\nexport default router;\n", "\nexport default () => Math.floor(Math.random() * Date.now());", "import mark from './mark';\nimport { createHTML } from './poly';\nimport { Expressions, HTML } from './types';\n// import parse from './parse';\n\nexport const symbol = Symbol('html');\nconst cache: WeakMap<TemplateStringsArray, [ HTMLTemplateElement, string ]> = new WeakMap();\n\nexport default function html (strings: TemplateStringsArray, ...expressions: Expressions): HTML {\n    const value = cache.get(strings);\n    if (value) {\n        const [ template, marker ] = value;\n\n        return { strings, template, expressions, symbol, marker };\n    } else {\n        const marker = `x-${mark()}-x`;\n        // const marker = `X-${mark()}-X`;\n\n        let data = '';\n\n        const length = strings.length - 1;\n\n        for (let index = 0; index < length; index++) {\n            data += `${strings[ index ]}${marker}`;\n        }\n\n        data += strings[ length ];\n\n        const template = document.createElement('template');\n        template.innerHTML = createHTML(data);\n\n        cache.set(strings, [ template, marker ]);\n\n        return { strings, template, expressions, symbol, marker };\n    }\n}\n", "\nexport const update = Symbol('XUpdate');\nexport const create = Symbol('XCreate');\n\nexport const created = Symbol('XCreated');\nexport const adopted = Symbol('XAdopted');\nexport const rendered = Symbol('XRendered');\nexport const connected = Symbol('XConnected');\nexport const attributed = Symbol('XAttributed');\nexport const disconnected = Symbol('XDisconnected');\n\nexport const tag = Symbol('XTag');\n// export const shadow = Symbol('XShadow');\nexport const extend = Symbol('XExtend');\nexport const internal = Symbol('XInternal');\n\nexport const state = Symbol('XState');\nexport const render = Symbol('XRender');\n", "import { replaceChildren } from './poly';\nimport { Component } from './types';\n\nconst init = (target: typeof Component, selector: string) => {\n\n    Object.defineProperties(target, { $mount: { value: selector } });\n\n    if (!target.$tag) throw new Error('static tag required');\n    if (!target.$mount) throw new Error('static mount required');\n\n    const $extend = target.$extend;\n    const $tag = target.$tag as string;\n    const $mount = target.$mount as string;\n\n    const ready = () => {\n        const container = $mount === 'body' ? document.body : document.querySelector($mount);\n        if (!container) throw new Error('XElement mount - container not found');\n\n        const element = document.createElement($extend || $tag, $extend ? { is: $tag } : undefined);\n\n        customElements.upgrade(element);\n        replaceChildren(container, element)\n    };\n\n    if (document.readyState === 'loading') {\n        document.addEventListener('readystatechange', ready, { once: true });\n    } else {\n        ready();\n    }\n\n    return target;\n};\n\nexport const mount = function (selector: string) {\n    return <T extends typeof Component> (constructor: T, context?: ClassDecoratorContext): T => {\n        if (context !== undefined) {\n            return context.addInitializer(() => init(constructor, selector)) as unknown as T;\n        } else {\n            return init(constructor, selector) as unknown as T;\n        }\n    }\n};\n\nexport default mount;\n", "import { replaceChildren } from './poly';\nimport context from './context';\nimport bind from './bind';\nimport dash from './dash';\n\nimport {\n    Internal,\n    Instance,\n    Component,\n} from './types';\n\nimport {\n    // tag,\n    // adopted,\n    // attributed,\n    // connected,\n    // create,\n    // created,\n    // disconnected,\n    internal,\n    // render,\n    // rendered,\n    // state,\n    // update,\n    // extend,\n    // shadow,\n} from './symbols';\n\nimport {\n    createdEvent,\n    creatingEvent,\n\n    renderedEvent,\n    renderingEvent,\n\n    adoptedEvent,\n    adoptingEvent,\n\n    connectedEvent,\n    connectingEvent,\n\n    attributedEvent,\n    attributingEvent,\n\n    disconnectedEvent,\n    disconnectingEvent,\n} from './events';\n\nconst tick = () => Promise.resolve();\n\nconst setupInstance = function (this: Instance) {\n    if (this.$internal.setup) return;\n    else this.$internal.setup = true;\n\n    // const constructor = this.constructor as typeof Component;\n    // const observedProperties = constructor.observedProperties;\n    // const prototype = Object.getPrototypeOf(this);\n    // const properties = observedProperties ?\n    //     observedProperties ?? [] :\n    //     [ ...Object.getOwnPropertyNames(this),\n    //     ...Object.getOwnPropertyNames(prototype) ];\n    // for (const property of properties) {\n    //     if (\n    //         'attributeChangedCallback' === property ||\n    //         'disconnectedCallback' === property ||\n    //         'connectedCallback' === property ||\n    //         'adoptedCallback' === property ||\n    //         'constructor' === property ||\n    //         'disconnected' === property ||\n    //         'attribute' === property ||\n    //         'connected' === property ||\n    //         'rendered' === property ||\n    //         'created' === property ||\n    //         'adopted' === property ||\n    //         'render' === property ||\n    //         'setup' === property\n    //     ) continue;\n    //     const descriptor = Object.getOwnPropertyDescriptor(this, property) ?? Object.getOwnPropertyDescriptor(prototype, property);\n    //     if (!descriptor) continue;\n    //     if (!descriptor.configurable) continue;\n    //     if (typeof descriptor.value === 'function') descriptor.value = descriptor.value.bind(this);\n    //     if (typeof descriptor.get === 'function') descriptor.get = descriptor.get.bind(this);\n    //     if (typeof descriptor.set === 'function') descriptor.set = descriptor.set.bind(this);\n    //     Object.defineProperty(this.#context, property, descriptor);\n    //     Object.defineProperty(this, property, {\n    //         configurable: false,\n    //         enumerable: descriptor.enumerable,\n    //         // configurable: descriptor.configurable,\n    //         get () {\n    //             return (this.#context as Record<any, any>)[ property ];\n    //         },\n    //         set (value) {\n    //             (this.#context as Record<any, any>)[ property ] = value;\n    //             this[ update ]();\n    //         }\n    //     });\n    // }\n\n};\n\nconst createMethod = async function (this: Instance) {\n    this.$internal.created = true;\n    this.$internal.queued = true;\n    this.$internal.started = true;\n\n\n\n    this.dispatchEvent(renderingEvent);\n\n    await this.$state?.(this.$internal.state);\n\n    const template = await this.$render?.(this.$internal.state);\n    if (template) {\n\n        // const fragment = document.importNode(template.template.content, true);\n        const fragment = template.template.content.cloneNode(true) as DocumentFragment;\n\n        this.$internal.marker = template.marker;\n        this.$internal.expressions = template.expressions;\n\n        bind(fragment, this.$internal.actions, this.$internal.marker);\n\n        for (let index = 0; index < this.$internal.actions.length; index++) {\n            const newExpression = template.expressions[ index ];\n            try {\n                this.$internal.actions[ index ](undefined, newExpression);\n            } catch (error) {\n                console.error(error);\n            }\n        }\n\n        document.adoptNode(fragment);\n\n        this.$internal.root.appendChild(fragment);\n    }\n\n    this.dispatchEvent(creatingEvent);\n    await this.$created?.(this.$internal.state)?.catch(console.error);\n    this.dispatchEvent(createdEvent);\n\n    this.dispatchEvent(connectingEvent);\n    await this.$connected?.(this.$internal.state)?.catch(console.error);\n    this.dispatchEvent(connectedEvent);\n\n    this.$internal.queued = false;\n    this.$internal.started = false;\n    this.$internal.restart = false;\n\n    await this.$internal.update();\n};\n\nconst updateMethod = async function (this: Instance) {\n\n    if (this.$internal.queued && !this.$internal.started) {\n        // console.debug('Update: queued and not started');\n        return this.$internal.task;\n    }\n\n    if (this.$internal.queued && this.$internal.started) {\n        // console.debug('Update: queued and started');\n        this.$internal.restart = true;\n        return this.$internal.task;\n    }\n\n    this.$internal.queued = true;\n    this.$internal.task = this.$internal.task.then(async () => {\n        // console.debug('Update: in progress');\n        // await tick();\n\n        this.dispatchEvent(renderingEvent);\n        const template = await this.$render?.(this.$internal.state);\n\n        this.$internal.started = true;\n\n        if (template) {\n            for (let index = 0; index < this.$internal.actions.length; index++) {\n\n                if (this.$internal.restart) {\n                    // console.debug('Update: restart');\n                    await tick();\n                    index = -1;\n                    this.$internal.restart = false;\n                    continue;\n                }\n\n                const newExpression = template.expressions[ index ];\n                const oldExpression = this.$internal.expressions[ index ];\n\n                try {\n                    this.$internal.actions[ index ](oldExpression, newExpression);\n                } catch (error) {\n                    console.error(error);\n                }\n\n                this.$internal.expressions[ index ] = template.expressions[ index ];\n            }\n\n        }\n\n        this.$internal.queued = false;\n        this.$internal.started = false;\n\n        await this.$rendered?.(this.$internal.state)?.catch(console.error);;\n        this.dispatchEvent(renderedEvent);\n\n    }).catch(console.error);\n\n    return this.$internal.task;\n};\n\nconst attributeChangedCallback = async function (this: Instance, name: string, oldValue: string, newValue: string) {\n    setupInstance.call(this);\n    this.dispatchEvent(attributingEvent);\n    await this.$attributed?.(name, oldValue, newValue)?.catch(console.error);\n    this.dispatchEvent(attributedEvent);\n};\n\nconst adoptedCallback = async function (this: Instance) {\n    setupInstance.call(this);\n    this.dispatchEvent(adoptingEvent);\n    await this.$adopted?.(this.$internal.state)?.catch(console.error);\n    this.dispatchEvent(adoptedEvent);\n};\n\nconst connectedCallback = async function (this: Instance) {\n    setupInstance.call(this);\n    if (!this.$internal.created) {\n        await this.$internal.create();\n    } else {\n        this.dispatchEvent(connectingEvent);\n        await this.$connected?.(this.$internal.state)?.catch(console.error);\n        this.dispatchEvent(connectedEvent);\n    }\n};\n\nconst disconnectedCallback = async function (this: Instance) {\n    setupInstance.call(this);\n    this.dispatchEvent(disconnectingEvent);\n    await this.$disconnected?.(this.$internal.state)?.catch(console.error);\n    this.dispatchEvent(disconnectedEvent);\n};\n\nconst init = (target: typeof Component, tag: string) => {\n\n    const $tag = dash(tag);\n\n    Object.defineProperties(target, { $tag: { value: $tag } });\n\n    Object.defineProperties(target.prototype, {\n        $internal: {\n            get() {\n                const $shadow = target.$shadow;\n                const value: Internal = {\n                    setup: false,\n                    queued: false,\n                    created: false,\n                    restart: false,\n                    started: false,\n                    marker: '',\n                    actions: [],\n                    expressions: [],\n                    task: Promise.resolve(),\n                    create: createMethod.bind(this),\n                    update: updateMethod.bind(this),\n                    state: {},\n                    // state: context({}, updateMethod.bind(this)),\n                    root: $shadow === 'open' || $shadow === 'closed' ? this.attachShadow({ mode: $shadow }) : this,\n                };\n                Object.defineProperty(this, '$internal', {\n                    value,\n                    writable: false,\n                    enumerable: false,\n                    configurable: false,\n                });\n                return value;\n            }\n        },\n        // [create]: { value: createMethod },\n        // [update]: { value: updateMethod },\n        adoptedCallback: { value: adoptedCallback },\n        connectedCallback: { value: connectedCallback },\n        disconnectedCallback: { value: disconnectedCallback },\n        attributeChangedCallback: { value: attributeChangedCallback },\n    });\n\n    // if (customElements.get(target.$tag as string) !== (target as any)) {\n    const $extend = target.$extend;\n    customElements.define($tag as string, (target as any), { extends: $extend });\n    // }\n\n    return target;\n};\n\nexport const define = function (tag: string) {\n    return function <T extends typeof Component>(constructor: T, context?: ClassDecoratorContext): T  {\n        if (context !== undefined) {\n            return context.addInitializer(() => init(constructor, tag)) as unknown as T;\n        } else {\n            return init(constructor, tag) as unknown as T;\n        }\n    }\n};\n\nexport default define;\n", "// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\n// https://www.w3.org/TR/REC-html40/index/attributes.html\nconst links = [\n    'src',\n    'href',\n    'data',\n    'action',\n    'srcdoc',\n    'xlink:href',\n    'cite',\n    'formaction',\n    'ping',\n    'poster',\n    'background',\n    'classid',\n    'codebase',\n    'longdesc',\n    'profile',\n    'usemap',\n    'icon',\n    'manifest',\n    'archive'\n];\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\nconst bools = [\n    'hidden',\n    'allowfullscreen',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected',\n];\n\nexport const isLink = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        links.indexOf(data) !== -1 :\n        false;\n};\n\nexport const isBool = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        bools.indexOf(data) !== -1 :\n        false;\n};\n\nconst patternValue = /^value$/i;\nexport const isValue = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternValue.test(data) :\n        false;\n};\n\nconst patternOn = /^on/i;\nexport const hasOn = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternOn.test(data) :\n        false;\n};\n\nexport const sliceOn = function (data: string): string {\n    return data && typeof data === 'string' ?\n        data?.toLowerCase()?.slice(2) :\n        '';\n};\n\nexport const isMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ?\n        data.toLowerCase() === marker.toLowerCase() :\n        false;\n};\n\nexport const hasMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ?\n        data.toLowerCase().indexOf(marker.toLowerCase()) !== -1 :\n        false;\n};\n\nexport const includes = function (item: string | Array<any>, search: any) {\n    return item.indexOf(search) !== -1;\n};\n\n// const safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\nconst safePattern = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nexport const dangerousLink = function (data: string) {\n    if (data === '') return false;\n    if (typeof data !== 'string') return false;\n    return safePattern.test(data) ? false : true;\n};\n\nexport const removeBetween = function (start: Node, end: Node) {\n    let node = end.previousSibling;\n    while (node !== start) {\n        node?.parentNode?.removeChild(node);\n        node = end.previousSibling;\n    }\n};\n", "\nexport default function display (data: any): string {\n    switch (`${data}`) {\n        case 'NaN': return '';\n        case 'null': return '';\n        case 'undefined': return '';\n    }\n    switch (typeof data) {\n        case 'string': return data;\n        case 'number': return `${data}`;\n        case 'bigint': return `${data}`;\n        case 'boolean': return `${data}`;\n        case 'function': return `${data()}`;\n        case 'symbol': return String(data);\n        case 'object': return JSON.stringify(data);\n    }\n    throw new Error('XElement - display type not handled');\n}\n", "import { hasOn, isMarker, isValue, sliceOn, isLink, isBool, hasMarker, dangerousLink, removeBetween } from './tools';\nimport display from './display';\nimport { symbol } from './html';\nimport { Actions } from './types';\n\n// const TEXT_NODE = Node.TEXT_NODE;\n// const ELEMENT_NODE = Node.ELEMENT_NODE;\n// const FILTER = NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT;\n\nconst FILTER = 1 + 4;\nconst TEXT_NODE = 3;\nconst ELEMENT_NODE = 1;\n\nconst ElementAction = function (\n    this: { start: Text, end: Text, actions: Actions, },\n    source: any,\n    target: any\n): void {\n\n    if (target?.symbol === symbol) {\n\n        source = source ?? {};\n        target = target ?? {};\n\n        if (source.strings === target.strings) {\n\n            const l = this.actions.length;\n            for (let i = 0; i < l; i++) {\n                this.actions[ i ](source.expressions[ i ], target.expressions[ i ]);\n            }\n\n        } else {\n            this.actions.length = 0;\n\n            // const fragment = document.importNode(target.template.content, true);\n            const fragment = target.template.content.cloneNode(true);\n\n            Bind(fragment, this.actions, target.marker);\n\n            const l = this.actions.length;\n            for (let i = 0; i < l; i++) {\n                this.actions[ i ](source.expressions?.[ i ], target.expressions[ i ]);\n            }\n\n            document.adoptNode(fragment);\n\n            removeBetween(this.start, this.end);\n            this.end.parentNode?.insertBefore(fragment, this.end);\n        }\n\n    } else if (target?.constructor === Array) {\n\n        source = source ?? [];\n        target = target ?? [];\n\n        const oldLength = source.length;\n        const newLength = target.length;\n        const common = Math.min(oldLength, newLength);\n\n        for (let i = 0; i < common; i++) {\n            this.actions[ i ](source[ i ], target[ i ]);\n        }\n\n        if (oldLength < newLength) {\n            const template = document.createElement('template');\n\n            for (let i = oldLength; i < newLength; i++) {\n\n                const startChild = document.createTextNode('');\n                const endChild = document.createTextNode('');\n                const action = ElementAction.bind({\n                    start: startChild,\n                    end: endChild,\n                    actions: []\n                });\n\n                template.content.appendChild(startChild);\n                template.content.appendChild(endChild);\n\n                this.actions.push(action);\n                action(source[ i ], target[ i ]);\n            }\n\n            this.end.parentNode?.insertBefore(template.content, this.end);\n        } else if (oldLength > newLength) {\n\n            for (let i = oldLength - 1; i > newLength - 1; i--) {\n                if (source[ i ]?.symbol === symbol) {\n                    const { template } = source[ i ];\n                    let removes = template.content.childNodes.length + 2;\n                    while (removes--) this.end.parentNode?.removeChild(this.end.previousSibling as Node);\n                } else {\n                    this.end.parentNode?.removeChild(this.end.previousSibling as Node);\n                    this.end.parentNode?.removeChild(this.end.previousSibling as Node);\n                    this.end.parentNode?.removeChild(this.end.previousSibling as Node);\n                }\n            }\n\n            this.actions.length = newLength;\n        }\n\n    } else {\n        if (source === target) {\n            return;\n        } else if (this.end.previousSibling === this.start) {\n            this.end.parentNode?.insertBefore(document.createTextNode(display(target)), this.end);\n        } else if (\n            this.end.previousSibling?.nodeType === TEXT_NODE &&\n            this.end.previousSibling?.previousSibling === this.start\n        ) {\n            this.end.previousSibling.textContent = display(target);\n        } else {\n            removeBetween(this.start, this.end);\n            this.end.parentNode?.insertBefore(document.createTextNode(display(target)), this.end);\n        }\n    }\n\n};\n\nconst AttributeNameAction = function (\n    this: { element: Element, name: string, value: any, },\n    source: any,\n    target: any\n): void {\n    if (source === target) {\n        return;\n    } else if (isValue(source)) {\n        this.element.removeAttribute(source);\n        Reflect.set(this.element, source, null);\n    } else if (hasOn(source)) {\n        if (typeof this.value === 'function') {\n            this.element.removeEventListener(sliceOn(source), this.value, true);\n        }\n    } else if (isLink(source)) {\n        this.element.removeAttribute(source);\n    } else if (isBool(source)) {\n        this.element.removeAttribute(source);\n        Reflect.set(this.element, source, false);\n    } else if (source) {\n        this.element.removeAttribute(source);\n        Reflect.deleteProperty(this.element, source);\n    }\n\n    this.name = target?.toLowerCase() || '';\n\n    if (!this.name) {\n        return;\n    } else if (hasOn(this.name)) {\n        return\n    } else if (isBool(this.name)) {\n        this.element.setAttribute(this.name, '');\n        Reflect.set(this.element, this.name, true);\n    } else {\n        this.element.setAttribute(this.name, '');\n        Reflect.set(this.element, this.name, undefined);\n    }\n\n};\n\nconst AttributeValueAction = function (\n    this: { element: Element, name: string, value: any, },\n    source: any,\n    target: any\n): void {\n    if (source === target) {\n        return;\n    } else if (isValue(this.name)) {\n\n        this.value = display(target);\n        if (!this.name) return;\n        this.element.setAttribute(this.name, this.value);\n        Reflect.set(this.element, this.name, this.value);\n\n    } else if (hasOn(this.name)) {\n\n    // console.log(this.name, source, target, this.element);\n        if (!this.name) return;\n\n        if (typeof this.value === 'function') {\n            this.element.removeEventListener(sliceOn(this.name), this.value, true);\n        }\n\n        if (typeof target !== 'function') {\n            return console.warn(`XElement - attribute name \"${this.name}\" and value \"${this.value}\" not allowed`);\n        }\n\n        this.value = function () { return target.call(this, ...arguments); };\n        this.element.addEventListener(sliceOn(this.name), this.value, true);\n\n    } else if (isLink(this.name)) {\n\n        this.value = encodeURI(target);\n        if (!this.name) return;\n\n        if (dangerousLink(this.value)) {\n            this.element.removeAttribute(this.name);\n            console.warn(`XElement - attribute name \"${this.name}\" and value \"${this.value}\" not allowed`);\n            return;\n        }\n\n        this.element.setAttribute(this.name, this.value);\n    } else {\n        this.value = target;\n        if (!this.name) return;\n        this.element.setAttribute(this.name, this.value);\n        Reflect.set(this.element, this.name, this.value);\n    }\n};\n\nconst TagAction = function (\n    this: { element: Element, holder: Text, },\n    source: any,\n    target: any\n): void {\n    if (source === target) return;\n\n    const oldElement = this.element;\n\n    if (target) {\n        oldElement.parentNode?.removeChild(oldElement);\n\n        const newElement = document.createElement(target) as Element;\n\n        while (oldElement.firstChild) newElement.appendChild(oldElement.firstChild);\n\n        if (oldElement.nodeType === ELEMENT_NODE) {\n            const attributeNames = (oldElement as Element).getAttributeNames();\n            for (const attributeName of attributeNames) {\n                const attributeValue = (oldElement as Element).getAttribute(attributeName) ?? '';\n                newElement.setAttribute(attributeName, attributeValue);\n            }\n        }\n\n        this.holder.parentNode?.insertBefore(newElement, this.holder);\n        this.element = newElement;\n    } else {\n        oldElement.parentNode?.removeChild(oldElement);\n        this.element = oldElement;\n    }\n\n};\n\nexport const Bind = function (fragment: DocumentFragment, actions: Actions, marker: string) {\n    const holders = new WeakSet();\n    const walker = document.createTreeWalker(fragment, FILTER, null);\n\n    walker.currentNode = fragment;\n\n    let node: Node | null = fragment.firstChild;\n\n    while (node = walker.nextNode()) {\n\n        if (holders.has(node.previousSibling as Node)) {\n            holders.delete(node.previousSibling as Node);\n            actions.push(() => undefined);\n        }\n\n        if (node.nodeType === TEXT_NODE) {\n\n            const startIndex = node.nodeValue?.indexOf(marker) ?? -1;\n            if (startIndex === -1) continue;\n\n            if (startIndex !== 0) {\n                (node as Text).splitText(startIndex);\n                node = walker.nextNode() as Node;\n            }\n\n            const endIndex = marker.length;\n            if (endIndex !== node.nodeValue?.length) {\n                (node as Text).splitText(endIndex);\n            }\n\n            const start = document.createTextNode('');\n            const end = node as Text;\n\n            end.textContent = '';\n            end.parentNode?.insertBefore(start, end);\n\n            actions.push(ElementAction.bind({ marker, start, end, actions: [], }));\n        } else if (node.nodeType === ELEMENT_NODE) {\n\n            if (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE') {\n                walker.nextSibling();\n            }\n\n            const tMeta: any = {\n                element: node as Element,\n            };\n\n            if (isMarker(node.nodeName, marker)) {\n                holders.add(node);\n                tMeta.holder = document.createTextNode('');\n                node.parentNode?.insertBefore(tMeta.holder, node);\n                actions.push(TagAction.bind(tMeta));\n            }\n\n            const names = (node as Element).getAttributeNames();\n            for (const name of names) {\n                const value = (node as Element).getAttribute(name) ?? '';\n\n                if (hasMarker(name, marker) || hasMarker(value, marker)) {\n\n                    const aMeta = {\n                        name,\n                        value,\n                        previous: undefined,\n                        get element () {\n                            return tMeta.element;\n                        },\n                    };\n\n                    if (hasMarker(name, marker)) {\n                        (node as Element).removeAttribute(name);\n                        actions.push(AttributeNameAction.bind(aMeta));\n                    }\n\n                    if (hasMarker(value, marker)) {\n                        (node as Element).removeAttribute(name);\n                        actions.push(AttributeValueAction.bind(aMeta));\n                    }\n\n                } else {\n                    if (isLink(name)) {\n                        if (dangerousLink(value)) {\n                            (node as Element).removeAttribute(name);\n                            console.warn(`XElement - attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (hasOn(name)) {\n                        (node as Element).removeAttribute(name);\n                        console.warn(`XElement - attribute name \"${name}\" not allowed`);\n                    }\n                }\n            }\n        } else {\n            console.warn(`XElement - node type \"${node.nodeType}\" not handled`);\n        }\n    }\n};\n\nexport default Bind;\n", "\nexport const adoptedEvent = new Event('adopted');\nexport const adoptingEvent = new Event('adopting');\n\nexport const upgradedEvent = new Event('upgraded');\nexport const upgradingEvent = new Event('upgrading');\n\nexport const creatingEvent = new Event('creating');\nexport const createdEvent = new Event('created');\n\nexport const renderingEvent = new Event('rendering');\nexport const renderedEvent = new Event('rendered');\n\nexport const connectedEvent = new Event('connected');\nexport const connectingEvent = new Event('connecting');\n\nexport const attributedEvent = new Event('attributed');\nexport const attributingEvent = new Event('attributing');\n\nexport const disconnectedEvent = new Event('disconnected');\nexport const disconnectingEvent = new Event('disconnecting');\n", "import { Component, Shadow } from './types'\n\nconst init = (target: typeof Component, mode: Shadow) => {\n\n    Object.defineProperties(target, {\n        $shadow: { value: mode ?? 'open' },\n    });\n\n    return target;\n};\n\nexport const shadow = function (mode: Shadow) {\n    return <T extends typeof Component> (constructor: T, context?: ClassDecoratorContext): T => {\n        if (context !== undefined) {\n            return context.addInitializer(() => init(constructor, mode)) as unknown as T;\n        } else {\n            return init(constructor, mode) as unknown as T;\n        }\n    }\n};\n\nexport default shadow;\n", "import { attributed, adopted, connected, created, disconnected, internal, render, rendered, tag, state, create, update, extend, shadow } from './symbols';\n\nexport type Action = (source: any, target: any) => void;\nexport type Actions = Array<Action>;\n\nexport type Expressions = Array<any>;\n\nexport type HTML = {\n    strings: TemplateStringsArray,\n    template: HTMLTemplateElement,\n    expressions: Expressions,\n    marker: string,\n    symbol: symbol,\n};\n\nexport type Attribute = { name: string, value: string; };\n\n// export type VirtualNode = FragmentNode | ElementNode | AttributeNode | TextNode;\n// export type VirtualNode = any;\n\nexport type Module = { default: CustomElementConstructor; };\nexport type Handler = () => Module | CustomElementConstructor | Promise<Module | CustomElementConstructor>;\nexport type Route = {\n    path: string;\n    root: Element;\n    handler: Handler;\n    tag?: string;\n    instance?: Element;\n    construct?: CustomElementConstructor;\n};\n\nexport type Shadow = 'open' | 'closed' | 'none';\n\nexport type DefineInit = string | {\n    tag?: string,\n    extend?: string,\n    shadow?: Shadow,\n}\n\nexport type MountInit = string | {\n    selector?: string,\n}\n\nexport type Internal = {\n    setup: boolean,\n    queued: boolean,\n    created: boolean,\n    restart: boolean,\n    started: boolean,\n    marker: string,\n    actions: Actions,\n    expressions: Expressions,\n    task: Promise<void>,\n    state: Record<any,any>,\n    root: Element | ShadowRoot,\n\n    create: () => Promise<void>,\n    update: () => Promise<void>,\n}\n\nexport abstract class Component extends HTMLElement {\n\n    /**\n     * The tag name.\n     */\n    static readonly $tag?: string;\n\n    /**\n     * A shdow of open, closed, or none (which does not use shadow) defaults to open.\n     */\n    static readonly  $shadow?: Shadow;\n\n    /**\n     * A selector that mounts an instance of the element.\n     */\n    static $mount?: string;\n\n    /**\n     * A tag name to extend.\n     */\n    static $extend?: string;\n\n    // abstract $state <S extends any>(state: S): void | Promise<void>;\n    abstract $state: (state: Record<any,any> | any) => void | Promise<void>;\n\n    /**\n     * Invoked when triggered from reactive properties.\n     * @category rendering\n     */\n    // abstract $render<S extends any>(state: S): HTML | Promise<HTML>;\n    abstract $render: (state: Record<any,any> | any) => HTML | Promise<HTML>;\n\n    /**\n     * Called one time when an element is created. cycle: Created -> Connected -> Rendered.\n     * @category lifecycle\n     */\n    $created?(context: Record<any, any>): void | Promise<void>;\n\n    /**\n     * Called every time the element is Connected to a document. cycle: Connected -> Rendered.\n     * @category lifecycle\n     */\n    $connected?(context: Record<any, any>): void | Promise<void>;\n\n    /**\n     * Called every time the element is needs to render. cycle: Rendered.\n     * @category lifecycle\n     */\n    $rendered?(context: Record<any, any>): void | Promise<void>;\n\n    /**\n     * Called every time the element disconnected from a document.\n     * @category lifecycle\n     */\n    $disconnected?(context: Record<any, any>): void | Promise<void>;\n\n    /**\n     * Called every time the element adopted into a new document.\n     * @category lifecycle\n     */\n    $adopted?(context: Record<any, any>): void | Promise<void>;\n\n    /**\n     * Called every an observed attribute changes.\n     */\n    $attributed?(name: string, from: string, to: string): void | Promise<void>;\n\n};\n\nexport interface Instance extends Component {\n    readonly $internal: Internal;\n\n    /**\n     * Invoked once on connectedCallback.\n     */\n    readonly [ create ]: () => Promise<void>;\n\n    /**\n     * Invoked every state change callback.\n     */\n    readonly [ update ]: () => Promise<void>;\n}", "import Router from './router';\nimport html from './html';\n\nimport * as symbols from './symbols';\nexport * from './symbols';\n\nimport * as mount from './mount';\nexport * from './mount';\n\nimport * as define from './define';\nexport * from './define';\n\nimport * as shadow from './shadow';\nexport * from './shadow';\n\nimport * as types from './types';\nexport * from './types';\n\nexport { Router };\nexport { Router as router };\n\nexport { html };\n\nexport default {\n\n    Router,\n    router: Router,\n\n    html,\n\n    ...mount,\n    ...shadow,\n    ...define,\n\n    ...symbols,\n    ...types,\n\n};\n\nexport const text = function (selector: string) {\n        console.log(arguments);\n    return function (target: any,  nameOrContext: string | ClassFieldDecoratorContext) {\n        console.log(arguments);\n        // if (nameOrContext === 'string') {\n        //     const reference = Symbol('XTextReference');\n        //     target[internal]\n        //     Object.defineProperties(target.prototype, {\n        //         [ nameOrContext ]: {\n        //             get () { return this[ reference ]; },\n        //             set (value) { this[ reference ] = value; },\n        //         }\n        //     });\n        // } else {\n\n        // }\n\n    }\n}", "import { define, text, mount, html, Component } from '../../source/index';\n\ninterface S {\n    count:number,\n}\n\n@mount('body')\n@define('x-test')\nclass XTest extends HTMLElement {\n// class XTest extends Component {\n    // class XTest extends HTMLElement implements Component {\n\n    @text('#count')\n    count = 0;\n\n    $state = (s:S) => {\n        s.count = 0;\n        setInterval(() => s.count++, 1000);\n    }\n\n    $render = (s:S) => html`\n        <strong>${s.count}</strong>\n        <strong id=\"count\"></strong>\n    `\n\n}"],
  "mappings": "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",
  "names": ["transition", "tick", "init", "tag", "init"]
}
