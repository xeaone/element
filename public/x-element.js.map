{
  "version": 3,
  "sources": ["../source/global.ts", "../source/tools.ts", "../source/attribute-name.ts", "../source/update.ts", "../source/attribute-value.ts", "../source/text.ts", "../source/action.ts", "../source/bind.ts", "../source/initialize.ts", "../source/index.ts"],
  "sourcesContent": ["import { Global } from './types';\n\nexport const global: Global = (window as any).XGLOBAL ?? ((window as any).XGLOBAL = Object.freeze({\n\n    // QueueNext: undefined,\n    // QueueCurrent: undefined,\n\n    BindersCache: new Set(),\n    TemplatesCache: new WeakMap(),\n    ContainersCache: new WeakMap(),\n\n    MarkerSymbol: Symbol('marker'),\n    InstanceSymbol: Symbol('instance'),\n    TemplateSymbol: Symbol('template'),\n    VariablesSymbol: Symbol('variables'),\n\n}));\n\nexport const {\n\n    // QueueNext,\n    // QueueCurrent,\n\n    BindersCache,\n    TemplatesCache,\n    ContainersCache,\n\n    MarkerSymbol,\n    InstanceSymbol,\n    TemplateSymbol,\n    VariablesSymbol,\n\n} = global;\n", "\nexport const {\n    SHOW_TEXT,\n    SHOW_ELEMENT,\n} = NodeFilter;\n\nexport const {\n    TEXT_NODE,\n    COMMENT_NODE,\n    ELEMENT_NODE,\n    ATTRIBUTE_NODE,\n    DOCUMENT_FRAGMENT_NODE,\n} = Node;\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\n// https://www.w3.org/TR/REC-html40/index/attributes.html\nconst links = [\n    'src',\n    'href',\n    'data',\n    'action',\n    'srcdoc',\n    'xlink:href',\n    'cite',\n    'formaction',\n    'ping',\n    'poster',\n    'background',\n    'classid',\n    'codebase',\n    'longdesc',\n    'profile',\n    'usemap',\n    'icon',\n    'manifest',\n    'archive',\n];\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\nconst bools = [\n    'hidden',\n    'allowfullscreen',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected',\n];\n\nexport const isLink = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        links.indexOf(data.toLowerCase()) !== -1 : false;\n};\n\nexport const isBool = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        bools.indexOf(data.toLowerCase()) !== -1 : false;\n};\n\nexport const isIterable = function (data: any): boolean {\n    return data && typeof data !== 'string' &&\n        typeof data[ Symbol.iterator ] === 'function';\n};\n\nconst patternAnimation = /^onanimation$/i;\nexport const isAnimation = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternAnimation.test(data) : false;\n};\n\nconst patternTimeout = /^ontimeout$/i;\nexport const isTimeout = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternTimeout.test(data) : false;\n};\n\nconst patternValue = /^value$/i;\nexport const isValue = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternValue.test(data) : false;\n};\n\nconst patternOn = /^on/i;\nexport const hasOn = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternOn.test(data) : false;\n};\n\nconst patternMarker = /^x-[0-9]{10}-x$/i;\nexport const isMarker = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternMarker.test(data) : false;\n};\n\nexport const matchMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ?\n        data === marker : false;\n};\n\nexport const hasMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ?\n        data.indexOf(marker) !== -1 : false;\n};\n\nexport const sliceOn = function (data: string): string {\n    return data && typeof data === 'string' ?\n        data?.toLowerCase()?.slice(2) :\n        '';\n};\n\n// export const includes = function (item: string | Array<any>, search: any) {\n//     return item.indexOf(search) !== -1;\n// };\n\nexport const mark = function (): string {\n    return `x-${`${Math.floor(Math.random() * Date.now())}`.slice(0, 10)}-x`;\n};\n\n// const safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\nconst safePattern = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nexport const dangerousLink = function (data: string): boolean {\n    if (data === '') return false;\n    if (typeof data !== 'string') return false;\n    return safePattern.test(data) ? false : true;\n};\n\n/**\n *  DOM mod methods\n */\n\nexport const removeBetween = function (start: Node, end: Node) {\n    let node = end.previousSibling;\n    while (node && node !== start) {\n        node.parentNode?.removeChild(node);\n        node = end.previousSibling;\n    }\n};\n\nexport const removeNode = function (node: Node): void {\n    (node.parentNode as Node).removeChild(node);\n};\n\nexport const beforeNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).insertBefore(node as Node, child);\n};\n\nexport const afterNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).insertBefore(node, child.nextSibling);\n};\n\nexport const replaceNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).replaceChild(node, child);\n};\n\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n    }\n\n    for (const node of nodes) {\n        element.appendChild(\n            typeof node === 'string' ?\n                (element.ownerDocument as Document).createTextNode(node) :\n                node\n        );\n    }\n\n};\n\n/**\n * Attr DOM\n */\n\nexport const addAttribute = function (owner: Element, attribute: Attr): Attr {\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const createAttribute = function (owner: Element, name: string, value?: string): Attr {\n    const attribute = owner.ownerDocument.createAttribute(name);\n    attribute.value = value ?? '';\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const removeAttribute = function (node: Attr): Attr {\n    return (node.ownerElement as Element).removeAttributeNode(node);\n};\n\n/**\n * Node methods\n */\n\nexport const isText = function (node: Node | null): boolean {\n    return node?.nodeType === TEXT_NODE;\n};\n\nexport const isAttribute = function (node: Node | null): boolean {\n    return node?.nodeType === ATTRIBUTE_NODE;\n};\n\nexport const isElement = function (node: Node | null): boolean {\n    return node?.nodeType === ELEMENT_NODE;\n};\n\nexport const isComment = function (node: Node | null): boolean {\n    return node?.nodeType === COMMENT_NODE;\n};", "import { hasOn, isBool, isLink, isValue, sliceOn } from './tools';\n\nexport const attributeName = function (element: Element, data: any, source: any, target: any): void {\n    console.log(arguments);\n\n    source = source?.toLowerCase() ?? '';\n    target = target?.toLowerCase() ?? '';\n\n    if (source === target) {\n        return;\n    }\n\n    if (hasOn(source)) {\n\n        if (typeof data.value === 'function') {\n            element.removeEventListener(sliceOn(source), data.value, true);\n        }\n\n    } else if (isValue(source)) {\n        element.removeAttribute(source);\n        Reflect.set(element, source, null);\n    } else if (isBool(source)) {\n        console.log(data, source, target);\n        element.removeAttribute(source);\n        Reflect.set(element, source, false);\n    } else if (isLink(source)) {\n        element.removeAttribute(source);\n        Reflect.deleteProperty(element, source);\n    } else if (source) {\n        element.removeAttribute(source);\n        Reflect.deleteProperty(element, source);\n    }\n\n    if (hasOn(target)) {\n        return;\n    } else if (isBool(target)) {\n        element.setAttribute(target, '');\n        Reflect.set(element, target, true);\n    } else if (target) {\n        element.setAttribute(target, '');\n        Reflect.set(element, target, null);\n    }\n\n    data.name = target || '';\n\n};", "import { BindersCache } from './global';\nimport { action } from './action';\n\nlet Next: Promise<void> | undefined;\nlet Current: Promise<void> | undefined;\n\nexport const next = async function (): Promise<void> {\n    await Current;\n    await new Promise(resolve => {\n        queueMicrotask(async () => {\n            Next = undefined;\n            await update();\n            resolve(undefined);\n        });\n    });\n};\n\nexport const update = async function (): Promise<void> {\n    if (Current) {\n        console.log('Is Current');\n        if (Next) {\n            console.log('Is Next');\n            await Next;\n        } else {\n            console.log('Not Next');\n            Next = next();\n            await Next;\n        }\n    } else {\n\n        // Current = (async () => {\n        //     const binders = BindersCache.values();\n\n        //     for (const binder of binders) {\n        //         try {\n        //             await action(binder);\n        //         } catch (error) {\n        //             console.error(error);\n        //         }\n        //     }\n\n        //     // Next = undefined;\n        //     Current = undefined;\n        // })();\n\n        Current = new Promise(resolve => {\n            queueMicrotask(async () => {\n                const binders = BindersCache.values();\n\n                for (const binder of binders) {\n                    try {\n                        await action(binder);\n                    } catch (error) {\n                        console.error(error);\n                    }\n                }\n\n                // Next = undefined;\n                Current = undefined;\n\n                resolve();\n            });\n        });\n\n        await Current;\n    }\n};\n", "import { isValue, hasOn, isLink, dangerousLink, sliceOn } from './tools.ts';\nimport { update } from './update.ts';\n\nexport const attributeValue = function (element: Element, data: any, source: any, target: any): void {\n    console.log(element, source, target);\n\n    if (source === target) {\n        return;\n    }\n\n    if (isValue(data.name)) {\n        data.value = target;\n        // data.value = display(target);\n        // if (!data.name) return;\n        element.setAttribute(data.name, data.value);\n        Reflect.set(element, data.name, data.value);\n    } else if (isLink(data.name)) {\n        data.value = encodeURI(target);\n        // if (!data.name) return;\n\n        if (dangerousLink(data.value)) {\n            element.removeAttribute(data.name);\n            console.warn(`XElement - attribute name \"${data.name}\" and value \"${data.value}\" not allowed`);\n            return;\n        }\n\n        element.setAttribute(data.name, data.value);\n    } else if (hasOn(data.name)) {\n        console.log(data);\n\n\n        if (element.hasAttribute(data.name)) {\n            element.removeAttribute(data.name);\n        }\n\n        if (typeof data.value === 'function') {\n            element.removeEventListener(sliceOn(data.name), data.value, true);\n        }\n\n        if (typeof target !== 'function') {\n            return console.warn(`XElement - attribute name \"${data.name}\" and value \"${data.value}\" not allowed`);\n        }\n\n        data.value = function () {\n            const result = target.call(this, ...arguments);\n            if (data.result !== result) {\n                data.result = result;\n                update();\n            }\n            return result;\n        };\n\n        element.addEventListener(sliceOn(data.name), data.value, true);\n\n    } else {\n        data.value = target;\n        // if (!data.name) return;\n        element.setAttribute(data.name, data.value);\n        Reflect.set(element, data.name, data.value);\n    }\n};\n\n\n// const attribute = function (node: Attr, binder: Binder, source: any, target: any) {\n//     const name = node.name;\n//     const value = node.value;\n\n//     if (hasOn(name)) {\n\n//         if (isAnimation(name)) {\n//             // const variable = binder.result;\n//             const isArray = Array.isArray(binder.result);\n//             const method = isArray ? binder.result[ 0 ] : binder.result;\n//             const handle = async () => {\n//                 if (binder.owner?.isConnected) {\n//                     const result = method();\n//                     if (binder.result === result) {\n//                         requestAnimationFrame(handle);\n//                     } else {\n//                         binder.result = result;\n//                         await update();\n//                         requestAnimationFrame(handle);\n//                     }\n//                 } else {\n//                     requestAnimationFrame(handle);\n//                 }\n//             };\n//             requestAnimationFrame(handle);\n//         } else if (isTimeout(name)) {\n//             // const variable = binder.variable;\n//             // const isArray = Array.isArray(variable);\n//             // const method = isArray ? variable[ 0 ] : variable;\n//             // const time = isArray ? variable[ 1 ] : undefined;\n\n//             const isArray = Array.isArray(binder.result);\n//             const method = isArray ? binder.result[ 0 ] : binder.result;\n//             const time = isArray ? binder.result[ 1 ] : undefined;\n//             const handle = async () => {\n//                 const result = method();\n//                 if (binder.result === result) {\n//                     return;\n//                 } else {\n//                     binder.result = result;\n//                     await update();\n//                 }\n//             };\n//             setTimeout(handle, time);\n//         } else {\n//             const owner = binder.owner;\n//             if (owner) {\n//                 const eventName = name.substring(2);\n//                 const isArray = Array.isArray(result);\n//                 const [ method, options ] = isArray ? result : [ result, undefined ];\n//                 if (typeof method === 'function') {\n//                     // owner.removeEventListener(eventName, result);\n//                     owner.addEventListener(eventName, async function (event) {\n//                         const returned = method(event);\n//                         if (binder.meta.returned !== returned) {\n//                             binder.meta.returned = returned;\n//                             await update();\n//                         }\n//                     }, options);\n//                     intersectionObserver.observe(owner);\n//                 } else {\n//                     console.error(`${name} requiures function or array with function`);\n//                 }\n//             }\n//         }\n\n//         const owner = binder.owner;\n//         if (owner) {\n//             owner.removeAttributeNode(node);\n//         }\n\n//     // } else if (isMarker(name)) {\n//     } else if (value === '') {\n//         if (name === result) {\n//             if (!binder.owner?.hasAttribute(result)) {\n//                 addAttribute(binder.owner as Element, node);\n//                 Reflect.set(binder.owner as Element, result, true);\n//             }\n//         } else {\n//             if (result) {\n//                 removeAttribute(node);\n//                 binder.replace(createAttribute(binder.owner as Element, result));\n//                 Reflect.set(binder.owner as Element, result, true);\n//             } else {\n//                 removeAttribute(node);\n//                 Reflect.set(binder.owner as Element, result, false);\n//             }\n//         }\n//     } else if (result instanceof Attr) {\n\n//     } else {\n//         node.value = result;\n//     }\n// };", "import { InstanceSymbol, TemplateSymbol, VariablesSymbol } from './global';\nimport { beforeNode, isIterable, removeBetween, removeNode } from './tools';\nimport { Binder } from './types';\n\nexport const text = function (node: Text, data: any, source: any, target: any) {\n\n    if (target === null || target === undefined) {\n        if (node.textContent === '') {\n            return;\n        } else {\n            node.textContent = '';\n        }\n    } else if (target instanceof Node) {\n\n        if (!data.start) {\n            data.start = document.createTextNode('');\n            beforeNode(data.start, node);\n        }\n\n        if (!data.end) {\n            node.textContent = '';\n            data.end = node;\n        }\n\n        removeBetween(data.start, data.end);\n        beforeNode(target, data.end);\n\n    } else if (target?.[ InstanceSymbol ]) {\n\n        if (!data.start) {\n            data.start = document.createTextNode('');\n            beforeNode(data.start, node);\n        }\n\n        if (!data.end) {\n            node.textContent = '';\n            data.end = node;\n        }\n\n        removeBetween(data.start, data.end);\n        beforeNode(target(), data.end);\n\n    } else if (isIterable(target)) {\n\n        if (data.length === undefined) {\n            data.length = 0;\n        }\n\n        if (!data.results) {\n            data.results = [];\n        }\n\n        if (!data.markers) {\n            data.markers = [];\n        }\n\n        if (!data.start) {\n            data.start = document.createTextNode('');\n            beforeNode(data.start, node);\n        }\n\n        if (!data.end) {\n            node.textContent = '';\n            data.end = node;\n        }\n\n        const oldLength = data.length;\n        const newLength = target.length;\n        const commonLength = Math.min(oldLength, newLength);\n\n        for (let index = 0; index < commonLength; index++) {\n\n            if (data.results[ index ]?.[TemplateSymbol] === target[ index ]?.[TemplateSymbol]) {\n                Object.assign(data.results[ index ][VariablesSymbol], target[ index ][VariablesSymbol]);\n            } else {\n                data.results[ index ] = target[ index ];\n            }\n\n        }\n\n        if (oldLength < newLength) {\n            while (data.length !== target.length) {\n                const marker = document.createTextNode('');\n                data.markers.push(marker);\n                data.results.push(target[ data.length ]);\n                beforeNode(marker, data.end);\n                // bind(marker, data.results, data.length);\n                data.length++;\n            }\n        } else if (oldLength > newLength) {\n            const last = data.markers[ target.length - 1 ];\n\n            while (data.length !== target.length) {\n                // const previous = data.end.previousSibling;\n                // removeNode(previous as Node);\n                // const last = data.markers[ data.markers.length - 1 ];\n                // if (previous === last) {\n                //     data.markers.pop();\n                //     data.results.pop();\n                //     data.length--;\n                // }\n\n                const previous = data.end.previousSibling;\n                if (previous === last) break;\n                removeNode(previous as Node);\n            }\n\n            data.length = target.length;\n            data.results.length = target.length;\n            data.markers.length = target.length;\n        }\n\n    } else {\n        if (node.textContent === `${target}`) {\n            return;\n        } else {\n            node.textContent = `${target}`;\n        }\n    }\n};", "import { attributeName } from './attribute-name';\nimport { attributeValue } from './attribute-value';\nimport { InstanceSymbol } from './global';\nimport { Binder } from './types';\nimport { text } from './text';\n\n/**\n * @module Action\n * @todo need to handle element name changes\n * @todo need to handle attribute name changes\n * @todo\n *\n */\n\nconst comment = function (node: Comment, data: any, source: any, target: any) {\n    console.warn('comment action not implemented');\n};\n\nconst element = function (node: Element, data: any, source: any, target: any) {\n    console.warn('element action not implemented');\n};\n\nexport const action = function (binder: Binder) {\n\n    const node = binder.node;\n\n    if (!node) {\n        return;\n    }\n\n    const variables = binder.variables;\n\n    // this optimization could prevent disconnected nodes from being render when re/connected\n    // Note: Attr nodes do not change the isConnected prop\n    // if (!node.isConnected && binder.isInitialized) {\n    //     return;\n    // }\n\n    for (const instruction of binder.instructions) {\n        const { type, data } = instruction;\n\n        const variable = variables[ instruction.index ];\n        const isFunction = typeof variable === 'function';\n        const isInstance = isFunction && (variable as any)[InstanceSymbol];\n        const isOnce = type === 3 && data.name.startsWith('on');\n        const isReactive = !isInstance && !isOnce && isFunction;\n\n        if (isOnce || isInstance || !isFunction) {\n            binder.instructions.splice(binder.instructions.indexOf(instruction), 1);\n            if (!binder.instructions) {\n                binder.remove();\n            }\n        }\n\n        const source = instruction.source;\n        const target = isReactive ? variable() : variable;\n\n        if ('source' in instruction && source === target) {\n            continue;\n        }\n\n        if (instruction.type === 1) {\n            element(node as Element, data, source, target);\n        } else if (instruction.type === 2) {\n            attributeName(node as Element, data, source, target);\n        } else if (instruction.type === 3) {\n            attributeValue(node as Element, data, source, target);\n        } else if (instruction.type === 4) {\n            text(node as Text, data, source, target);\n        } else {\n            throw new Error('instruction type not valid');\n        }\n\n        instruction.source = target;\n    }\n\n};", "import { Binder, Instructions, Reference, References, Variables } from './types';\nimport { BindersCache } from './global';\nimport { action } from './action';\n\nexport const bind = function (variables: Variables, instructions: Instructions, reference: Reference) {\n\n    const binder: Binder = {\n\n        reference,\n\n        get node () {\n            const node = reference.deref();\n            if (node) {\n                return node;\n            } else {\n                console.log('binder remove by no node');\n                BindersCache.delete(this);\n                return null;\n            }\n        },\n\n        get instructions () {\n            if (!instructions.length) {\n                BindersCache.delete(this);\n            }\n            return instructions;\n        },\n\n        get variables () {\n            return variables;\n        },\n\n        remove () {\n            BindersCache.delete(this);\n        },\n\n    };\n\n    BindersCache.add(binder);\n\n    action(binder);\n\n};", "import { ELEMENT_NODE, SHOW_ELEMENT, SHOW_TEXT, TEXT_NODE, dangerousLink, hasMarker, hasOn, isLink, matchMarker, replaceChildren } from './tools';\nimport { Marker, Template, Variables, Container, Instructions, Reference } from './types';\nimport { ContainersCache } from './global';\nimport { update } from './update';\nimport { bind } from './bind';\n\nconst FILTER = SHOW_ELEMENT + SHOW_TEXT;\n\n// type ReferenceId = symbol;\n// type ReferenceNode = WeakRef<Element | Attr | Text>;\n// const References: Map<ReferenceKey, ReferenceValue> = new Map();\n\nexport const initialize = function (template: Template, variables: Variables, marker: Marker, container?: Container): Element | DocumentFragment {\n\n    // if (typeof container === 'string') {\n    //     const selection = document.querySelector(container);\n    //     if (!selection) throw new Error('query not found');\n    //     const cache = ContainersCache.get(selection);\n    //     if (cache && cache === template) {\n    //         update();\n    //         return selection;\n    //     } else {\n    //         ContainersCache.set(selection, template);\n    //     }\n    // } else if (container instanceof Element) {\n    //     const cache = ContainersCache.get(container);\n    //     if (cache && cache === template) {\n    //         update();\n    //         return container;\n    //     } else {\n    //         ContainersCache.set(container, template);\n    //     }\n    //     console.log(ContainersCache)\n    // }\n\n    const fragment = template.content.cloneNode(true) as DocumentFragment;\n    const walker = document.createTreeWalker(fragment, FILTER, null);\n\n    // let text: Text;\n    // let attribute: Attr;\n    // let element: Element;\n\n    // let type: number;\n    // let name: string;\n    // let value: string;\n    // let names: string[];\n    let node: Node | null;\n\n    let startIndex: number;\n    let endIndex: number;\n\n    let index = 0;\n\n    while (walker.nextNode()) {\n        node = walker.currentNode;\n        const type = node.nodeType;\n\n        if (type === TEXT_NODE) {\n            let text = node as Text;\n\n            startIndex = text.nodeValue?.indexOf(marker) ?? -1;\n            if (startIndex === -1) continue;\n\n            if (startIndex !== 0) {\n                text.splitText(startIndex);\n                node = walker.nextNode() as Node | null;\n                text = node as Text;\n            }\n\n            endIndex = marker.length;\n            if (endIndex !== text.nodeValue?.length) {\n                text.splitText(endIndex);\n            }\n\n            const reference: Reference = new WeakRef(text);\n            const instructions: Instructions = [{ type: 4, index: index++, data: {} }];\n            bind(variables, instructions, reference);\n\n        } else if (type === ELEMENT_NODE) {\n            const element = node as Element;\n            const tag = element.tagName.toLowerCase();\n\n            if (tag === 'STYLE' || tag === 'SCRIPT') {\n                walker.nextSibling();\n            }\n\n            let instructions: Instructions | undefined;\n            let reference: Reference | undefined;\n\n            if (matchMarker(tag, marker)) {\n                reference = new WeakRef(element);\n                instructions = [{ type: 1, index: index++, data: { tag } }];\n            }\n\n            const names = element.getAttributeNames();\n            for (const name of names) {\n                const value = element.getAttribute(name) ?? '';\n                const matchMarkerName = matchMarker(name, marker);\n                const hasMarkerValue = hasMarker(value, marker);\n\n                if (matchMarkerName || hasMarkerValue) {\n\n                    reference = reference ?? new WeakRef(element);\n                    instructions = instructions ?? [];\n\n                    const data = { name, value };\n\n                    if (matchMarkerName) {\n                        data.name = '';\n                        instructions.push({ type: 2, index: index++, data });\n                    }\n\n                    if (hasMarkerValue) {\n                        data.value = '';\n                        instructions.push({ type: 3, index: index++, data });\n                    }\n\n                    element.removeAttribute(name);\n                } else {\n                    if (isLink(name)) {\n                        if (dangerousLink(value)) {\n                            element.removeAttribute(name);\n                            console.warn(`attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (hasOn(name)) {\n                        element.removeAttribute(name);\n                        console.warn(`attribute name \"${name}\" not allowed`);\n                    }\n                }\n\n            }\n\n            if (instructions && reference) {\n                bind(variables, instructions, reference);\n            }\n\n        } else {\n            console.warn(`walker node type \"${type}\" not handled`);\n        }\n    }\n\n    if (typeof container === 'string') {\n        const selection = document.querySelector(container);\n        if (!selection) throw new Error('query not found');\n        replaceChildren(selection, fragment);\n        return selection;\n    } else if (container instanceof Element) {\n        replaceChildren(container, fragment)\n        return container;\n    } else {\n        return fragment;\n    }\n\n};\n", "import { InstanceSymbol, MarkerSymbol, TemplateSymbol, TemplatesCache, VariablesSymbol } from './global';\nimport { Initialize, Variables } from './types';\nimport { initialize } from './initialize';\nimport { update } from './update';\nimport { mark } from './tools';\n\n// const query = (node: Node, selector: Selector) => selector.reduce((n, s) => n[ s ], node);\n\nexport { update };\n\n/**\n *\n * @description\n * @param strings\n * @param variables\n * @returns {DocumentFragment}\n */\n\nexport const html = function (strings: TemplateStringsArray, ...variables: Variables): Initialize {\n    let marker: string;\n    let template: HTMLTemplateElement;\n\n    const cache = TemplatesCache.get(strings);\n\n    if (cache) {\n        marker = cache.marker;\n        template = cache.template;\n    } else {\n        marker = mark();\n\n        let innerHTML = '';\n\n        const length = strings.length - 1;\n        for (let index = 0; index < length; index++) {\n            innerHTML += `${strings[ index ]}${marker}`;\n        }\n\n        innerHTML += strings[ length ];\n\n        template = document.createElement('template');\n        template.innerHTML = innerHTML;\n\n        TemplatesCache.set(strings, { template, marker });\n    }\n\n    const meta = {\n        [ InstanceSymbol ]: true,\n        [ MarkerSymbol ]: marker,\n        [ TemplateSymbol ]: template,\n        [ VariablesSymbol ]: variables,\n    };\n\n    return Object.assign(initialize.bind(meta, template, variables, marker), meta);\n};\n"],
  "mappings": "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",
  "names": ["element", "element", "element", "text", "element"]
}
