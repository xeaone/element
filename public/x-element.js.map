{
  "version": 3,
  "sources": ["../source/global.ts", "../source/tools.ts", "../source/intersection.ts", "../source/update.ts", "../source/action.ts", "../source/bind.ts", "../source/initialize.ts", "../source/index.ts"],
  "sourcesContent": ["import { Global } from './types';\n\nexport const global: Global = (window as any).XGLOBAL ?? ((window as any).XGLOBAL = Object.freeze({\n\n    // QueueNext: undefined,\n    // QueueCurrent: undefined,\n\n    BindersCache: new Set(),\n    TemplatesCache: new WeakMap(),\n    ContainersCache: new WeakMap(),\n\n    MarkerSymbol: Symbol('marker'),\n    InstanceSymbol: Symbol('instance'),\n    TemplateSymbol: Symbol('template'),\n    VariablesSymbol: Symbol('variables'),\n\n}));\n\nexport const {\n\n    // QueueNext,\n    // QueueCurrent,\n\n    BindersCache,\n    TemplatesCache,\n    ContainersCache,\n\n    MarkerSymbol,\n    InstanceSymbol,\n    TemplateSymbol,\n    VariablesSymbol,\n\n} = global;\n", "\nexport const {\n    SHOW_TEXT,\n    SHOW_ELEMENT,\n} = NodeFilter;\n\nexport const {\n    TEXT_NODE,\n    COMMENT_NODE,\n    ELEMENT_NODE,\n    ATTRIBUTE_NODE,\n    DOCUMENT_FRAGMENT_NODE,\n} = Node;\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\n// https://www.w3.org/TR/REC-html40/index/attributes.html\nconst links = [\n    'src',\n    'href',\n    'data',\n    'action',\n    'srcdoc',\n    'xlink:href',\n    'cite',\n    'formaction',\n    'ping',\n    'poster',\n    'background',\n    'classid',\n    'codebase',\n    'longdesc',\n    'profile',\n    'usemap',\n    'icon',\n    'manifest',\n    'archive',\n];\n\n// https://html.spec.whatwg.org/multipage/indices.html#attributes-1\nconst bools = [\n    'hidden',\n    'allowfullscreen',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected',\n];\n\nexport const isLink = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        links.indexOf(data.toLowerCase()) !== -1 : false;\n};\n\nexport const isBool = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        bools.indexOf(data.toLowerCase()) !== -1 : false;\n};\n\nexport const isIterable = function (data: any): boolean {\n    return data && typeof data !== 'string' &&\n        typeof data[ Symbol.iterator ] === 'function';\n};\n\nconst patternAnimation = /^onanimation$/i;\nexport const isAnimation = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternAnimation.test(data) : false;\n};\n\nconst patternTimeout = /^ontimeout$/i;\nexport const isTimeout = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternTimeout.test(data) : false;\n};\n\nconst patternValue = /^value$/i;\nexport const isValue = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternValue.test(data) : false;\n};\n\nconst patternOn = /^on/i;\nexport const hasOn = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternOn.test(data) : false;\n};\n\n// export const sliceOn = function (data: string): string {\n//     return data && typeof data === 'string' ?\n//         data?.toLowerCase()?.slice(2) :\n//         '';\n// };\n\nconst patternMarker = /^x-[0-9]{10}-x$/;\nexport const isMarker = function (data: string): boolean {\n    return data && typeof data === 'string' ?\n        patternMarker.test(data) : false;\n};\n\n// export const isMarker = function (data: string, marker: string): boolean {\n//     return data && typeof data === 'string' ?\n//         data === marker : false;\n// };\n\nexport const hasMarker = function (data: string, marker: string): boolean {\n    return data && typeof data === 'string' ?\n        data.indexOf(marker) !== -1 : false;\n};\n\n// export const includes = function (item: string | Array<any>, search: any) {\n//     return item.indexOf(search) !== -1;\n// };\n\nexport const mark = function (): string {\n    return `x-${`${Math.floor(Math.random() * Date.now())}`.slice(0, 10)}-x`;\n};\n\n// const safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\nconst safePattern = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nexport const dangerousLink = function (data: string): boolean {\n    if (data === '') return false;\n    if (typeof data !== 'string') return false;\n    return safePattern.test(data) ? false : true;\n};\n\n/**\n *  DOM mod methods\n */\n\nexport const removeBetween = function (start: Node, end: Node) {\n    let node = end.previousSibling;\n    while (node && node !== start) {\n        node.parentNode?.removeChild(node);\n        node = end.previousSibling;\n    }\n};\n\nexport const removeNode = function (node: Node): void {\n    (node.parentNode as Node).removeChild(node);\n};\n\nexport const beforeNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).insertBefore(node as Node, child);\n};\n\nexport const afterNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).insertBefore(node, child.nextSibling);\n};\n\nexport const replaceNode = function (node: Node, child: Node): void {\n    (child.parentNode as Node).replaceChild(node, child);\n};\n\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n    }\n\n    for (const node of nodes) {\n        element.appendChild(\n            typeof node === 'string' ?\n                (element.ownerDocument as Document).createTextNode(node) :\n                node\n        );\n    }\n\n};\n\nexport const createAttribute = function (owner: Element, name: string, value?: string): Attr {\n    const attribute = owner.ownerDocument.createAttribute(name);\n    attribute.value = value ?? '';\n    owner.setAttributeNode(attribute);\n    return attribute;\n};\n\nexport const removeAttribute = function (node: Attr): Attr {\n    return (node.ownerElement as Element).removeAttributeNode(node);\n};\n\n/**\n * Node methods\n */\n\nexport const isText = function (node: Node | null): boolean {\n    return node?.nodeType === TEXT_NODE;\n};\n\nexport const isAttribute = function (node: Node | null): boolean {\n    return node?.nodeType === ATTRIBUTE_NODE;\n};\n\nexport const isElement = function (node: Node | null): boolean {\n    return node?.nodeType === ELEMENT_NODE;\n};\n\nexport const isComment = function (node: Node | null): boolean {\n    return node?.nodeType === COMMENT_NODE;\n};", "\n\nconst connectedEvent = new CustomEvent('connected');\n\nconst disconnectedEvent = new CustomEvent('disconnected');\n\nconst intersectionElements: WeakMap<Element, { wasConnected: boolean, isIntersecting: boolean; }> = new WeakMap();\n\nexport const intersectionObserver = new IntersectionObserver((entries) => {\n    for (const entry of entries) {\n        const intersectionElement = intersectionElements.get(entry.target);\n        if (!intersectionElement) {\n            intersectionElements.set(entry.target, { wasConnected: false, isIntersecting: entry.isIntersecting });\n        } else if (entry.target.isConnected === true && intersectionElement.wasConnected === false) {\n            intersectionElement.wasConnected = true;\n            intersectionElement.isIntersecting = entry.isIntersecting;\n            entry.target.dispatchEvent(connectedEvent);\n        } else if (entry.target.isConnected === false && intersectionElement.wasConnected === true) {\n            intersectionElement.wasConnected = false;\n            intersectionElement.isIntersecting = entry.isIntersecting;\n            entry.target.dispatchEvent(disconnectedEvent);\n        } else {\n            //\n        }\n    }\n}, {\n    threshold: 1,\n    // rootMargin: '100000%',\n    root: document.documentElement,\n});", "import { BindersCache } from './global';\nimport { action } from './action';\n\nlet Next: Promise<void> | undefined;\nlet Current: Promise<void> | undefined;\n\nexport const next = async function (): Promise<void> {\n    await Current;\n    await (new Promise(resolve => {\n        queueMicrotask(async () => {\n            Next = undefined;\n            await update();\n            resolve(undefined);\n        });\n    }));\n};\n\nexport const update = async function (): Promise<void> {\n    if (Current) {\n        console.log('Is Current');\n        if (Next) {\n            console.log('Is Next');\n            await Next;\n        } else {\n            console.log('Not Next');\n            Next = next();\n            await Next;\n        }\n    } else {\n\n        Current = (async () => {\n            const binders = BindersCache.values();\n\n            for (const binder of binders) {\n                try {\n                    await action(binder);\n                } catch (error) {\n                    console.error(error);\n                }\n            }\n\n            // Next = undefined;\n            Current = undefined;\n        })();\n\n        await Current;\n    }\n};\n", "import { TemplateSymbol, BindersCache, VariablesSymbol, InstanceSymbol } from './global';\nimport { ATTRIBUTE_NODE, afterNode, beforeNode, createAttribute, hasOn, isAnimation, isAttribute, isBool, isComment, isElement, isIterable, isMarker, isText, isTimeout, removeAttribute, removeBetween, removeNode, replaceNode } from './tools';\nimport { intersectionObserver } from './intersection';\nimport { update } from './update';\nimport { Binder } from './types';\nimport { bind } from './bind';\n\n/**\n * @module Action\n * @todo need to handle element name changes\n * @todo need to handle attribute name changes\n * @todo\n *\n */\n\nconst comment = function (node: Comment, binder: Binder, result: any) {\n    console.warn('comment action not implemented');\n};\n\nconst element = function (node:Element, binder: Binder, result: any) {\n    console.warn('element action not implemented');\n};\n\nconst attribute = function (node: Attr, binder: Binder, result: any) {\n    const name = node.name;\n\n\n    if (hasOn(name)) {\n\n        if (isAnimation(name)) {\n            // const variable = binder.result;\n            const isArray = Array.isArray(binder.result);\n            const method = isArray ? binder.result[ 0 ] : binder.result;\n            const handle = async () => {\n                if (binder.owner?.isConnected) {\n                    const result = method();\n                    if (binder.result === result) {\n                        requestAnimationFrame(handle);\n                    } else {\n                        binder.result = result;\n                        await update();\n                        requestAnimationFrame(handle);\n                    }\n                } else {\n                    requestAnimationFrame(handle);\n                }\n            };\n            requestAnimationFrame(handle);\n        } else if (isTimeout(name)) {\n            // const variable = binder.variable;\n            // const isArray = Array.isArray(variable);\n            // const method = isArray ? variable[ 0 ] : variable;\n            // const time = isArray ? variable[ 1 ] : undefined;\n\n            const isArray = Array.isArray(binder.result);\n            const method = isArray ? binder.result[ 0 ] : binder.result;\n            const time = isArray ? binder.result[ 1 ] : undefined;\n            const handle = async () => {\n                const result = method();\n                if (binder.result === result) {\n                    return;\n                } else {\n                    binder.result = result;\n                    await update();\n                }\n            };\n            setTimeout(handle, time);\n        } else {\n            const owner = binder.owner;\n            if (owner) {\n                const eventName = name.substring(2);\n                const isArray = Array.isArray(result);\n                const [ method, options ] = isArray ? result : [ result, undefined ];\n                if (typeof method === 'function') {\n                    // owner.removeEventListener(eventName, result);\n                    owner.addEventListener(eventName, async function (event) {\n                        const returned = method(event);\n                        if (binder.meta.returned !== returned) {\n                            binder.meta.returned = returned;\n                            await update();\n                        }\n                    }, options);\n                    intersectionObserver.observe(owner);\n                } else {\n                    console.error(`${name} requiures function or array with function`);\n                }\n            }\n        }\n\n        const owner = binder.owner;\n        if (owner) {\n            owner.removeAttributeNode(node);\n        }\n\n    // } else if (isMarker(name)) {\n    } else if (node.value === '') {\n        console.log(node.name, node.value, name, result);\n        if (name !== result) {\n            if (result) {\n                binder.replace(createAttribute(binder.owner, result));\n                removeAttribute(node);\n                Reflect.set(binder.owner, result, true);\n            } else {\n                removeAttribute(node);\n                Reflect.set(binder.owner, result, true);\n            }\n        }\n    } else if (result instanceof Attr) {\n\n    } else {\n        node.value = result;\n    }\n};\n\nconst text = function (node: Text, binder: Binder, result: any) {\n\n    if (result === null || result === undefined) {\n        if (node.textContent === '') {\n            return;\n        } else {\n            node.textContent = '';\n        }\n    } else if (result instanceof Node) {\n\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        removeBetween(binder.start, binder.end);\n        beforeNode(result, binder.end);\n\n    } else if (result?.[ InstanceSymbol ]) {\n\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        removeBetween(binder.start, binder.end);\n        beforeNode(result(), binder.end);\n\n    } else if (isIterable(result)) {\n\n        if (binder.length === undefined) {\n            binder.length = 0;\n        }\n\n        if (!binder.results) {\n            binder.results = [];\n        }\n\n        if (!binder.markers) {\n            binder.markers = [];\n        }\n\n        if (!binder.start) {\n            binder.start = document.createTextNode('');\n            beforeNode(binder.start, node);\n        }\n\n        if (!binder.end) {\n            node.textContent = '';\n            binder.end = node;\n        }\n\n        const oldLength = binder.length;\n        const newLength = result.length;\n        const commonLength = Math.min(oldLength, newLength);\n\n        for (let index = 0; index < commonLength; index++) {\n\n            if (binder.results[ index ]?.[TemplateSymbol] === result[ index ]?.[TemplateSymbol]) {\n                Object.assign(binder.results[ index ][VariablesSymbol], result[ index ][VariablesSymbol]);\n            } else {\n                binder.results[ index ] = result[ index ];\n            }\n\n        }\n\n        if (oldLength < newLength) {\n            while (binder.length !== result.length) {\n                const marker = document.createTextNode('');\n                binder.markers.push(marker);\n                binder.results.push(result[ binder.length ]);\n                beforeNode(marker, binder.end);\n                bind(marker, binder.results, binder.length);\n                binder.length++;\n            }\n        } else if (oldLength > newLength) {\n            const last = binder.markers[ result.length - 1 ];\n\n            while (binder.length !== result.length) {\n                // const previous = binder.end.previousSibling;\n                // removeNode(previous as Node);\n                // const last = binder.markers[ binder.markers.length - 1 ];\n                // if (previous === last) {\n                //     binder.markers.pop();\n                //     binder.results.pop();\n                //     binder.length--;\n                // }\n\n                const previous = binder.end.previousSibling;\n                if (previous === last) break;\n                removeNode(previous as Node);\n            }\n\n            binder.length = result.length;\n            binder.results.length = result.length;\n            binder.markers.length = result.length;\n        }\n\n    } else {\n        if (node.textContent === `${result}`) {\n            return;\n        } else {\n            node.textContent = `${result}`;\n        }\n    }\n};\n\nexport const action = function (binder: Binder) {\n    const node = binder.node;\n\n    if (!node) {\n        return;\n    }\n\n    // this optimization could prevent disconnected nodes from being render when re/connected\n    // Note: Attr nodes do not change the isConnected prop\n    // if (!node.isConnected && binder.isInitialized) {\n    //     return;\n    // }\n\n    const variable = binder.variable;\n    const isFunction = typeof variable === 'function';\n    const isInstance = isFunction && variable[InstanceSymbol];\n    const isOnce = node.nodeType === ATTRIBUTE_NODE && (node as Attr)?.name.startsWith('on');\n    const isReactive = !isInstance && !isOnce && isFunction;\n\n    // move this to the Binder\n    if (!isReactive || isOnce) {\n        binder.remove();\n    }\n\n    let result: any;\n    if (isReactive) {\n        result = variable();\n    } else {\n        result = variable;\n    }\n\n    if (binder.result === result) {\n        return;\n    }\n\n    if (binder.result?.constructor !== result?.constructor) {\n        delete binder.start;\n        delete binder.end;\n        delete binder.markers;\n        delete binder.results;\n        delete binder.length;\n    }\n\n    if (isText(node)) {\n        text(node as Text, binder, result);\n    } else if (isAttribute(node)) {\n        attribute(node as Attr, binder, result);\n    } else if (isElement(node)) {\n        element(node as Element, binder, result);\n    } else if (isComment(node)) {\n        comment(node as Comment, binder, result);\n    } else {\n        console.warn(`action node type \"${node.nodeType}\" not handled`);\n    }\n\n    // if (\n    //     binder.result &&\n    //     typeof binder.result === 'object' &&\n    //     'length' in binder.result &&\n    //     result &&\n    //     typeof result === 'object' &&\n    //     'length' in result\n    // ) {\n    //     console.log(result);\n    // } else {\n    //     binder.result = result;\n    // }\n\n    binder.result = result;\n\n    // binder.isInitialized = true;\n\n};", "import { InstanceSymbol, BindersCache } from './global';\nimport { Binder, Variables } from './types';\nimport { ATTRIBUTE_NODE } from './tools';\nimport { action } from './action';\n\nexport const bind = function (node: Node, variables: Variables, index: number) {\n\n    // const type = node.nodeType;\n    // const isAttribute = type === ATTRIBUTE_NODE;\n\n    // const isFunction = typeof variables[ index ] === 'function';\n    // const isInstance = isFunction && variables[ index ][InstanceSymbol];\n    // const isOnce = isAttribute && (node as Attr)?.name.startsWith('on');\n    // const isReactive = !isInstance && !isOnce && isFunction;\n\n    const binder: Binder = {\n\n        meta: {},\n        result: undefined,\n\n        nodeReference: new WeakRef(node),\n\n        get node () {\n            const node = this.nodeReference.deref();\n            if (node) {\n                return node;\n            } else {\n                BindersCache.delete(this);\n                return null;\n            }\n        },\n\n        ownerReference:\n            (node as Attr).ownerElement || node.parentElement ?\n            new WeakRef(((node as Attr).ownerElement ?? node.parentElement) as Element) : undefined,\n\n        get owner () {\n            const node = this.ownerReference?.deref();\n            if (node) {\n                return node;\n            } else {\n                BindersCache.delete(this);\n                return null;\n            }\n        },\n\n        get variable () {\n            return variables[ index ];\n        },\n\n        remove () {\n            BindersCache.delete(this);\n        },\n\n        replace (node: Node) {\n            this.nodeReference = new WeakRef(node);\n        },\n\n        // isOnce,\n        // isReactive,\n        // isInstance,\n        // isInitialized: false,\n    };\n\n    // if (isReactive) {\n    //     BindersCache.add(binder);\n    // }\n\n    BindersCache.add(binder);\n\n    action(binder);\n\n};", "import { ELEMENT_NODE, SHOW_ELEMENT, SHOW_TEXT, TEXT_NODE, dangerousLink, hasMarker, hasOn, isLink, isMarker, replaceChildren } from './tools';\nimport { Marker, Template, Variables, Container } from './types';\nimport { ContainersCache } from './global';\nimport { update } from './update';\nimport { bind } from './bind';\n\nconst FILTER = SHOW_ELEMENT + SHOW_TEXT;\n\nexport const initialize = function (template: Template, variables: Variables, marker: Marker, container?: Container): Element | DocumentFragment {\n\n    // if (typeof container === 'string') {\n    //     const selection = document.querySelector(container);\n    //     if (!selection) throw new Error('query not found');\n    //     const cache = ContainersCache.get(selection);\n    //     if (cache && cache === template) {\n    //         update();\n    //         return selection;\n    //     } else {\n    //         ContainersCache.set(selection, template);\n    //     }\n    // } else if (container instanceof Element) {\n    //     const cache = ContainersCache.get(container);\n    //     if (cache && cache === template) {\n    //         update();\n    //         return container;\n    //     } else {\n    //         ContainersCache.set(container, template);\n    //     }\n    //     console.log(ContainersCache)\n    // }\n\n    const fragment = template.content.cloneNode(true) as DocumentFragment;\n    const walker = document.createTreeWalker(fragment, FILTER, null);\n\n    let text: Text;\n    let attribute: Attr;\n    let element: Element;\n\n    let type: number;\n    let name: string;\n    let value: string;\n    let names: string[];\n    let node: Node | null;\n\n    let startIndex: number;\n    let endIndex: number;\n\n    let index = 0;\n\n    while (walker.nextNode()) {\n        node = walker.currentNode;\n        type = node.nodeType;\n\n        if (type === TEXT_NODE) {\n            text = node as Text;\n\n            startIndex = text.nodeValue?.indexOf(marker) ?? -1;\n            if (startIndex === -1) continue;\n\n            if (startIndex !== 0) {\n                text.splitText(startIndex);\n                node = walker.nextNode();\n                text = node as Text;\n            }\n\n            endIndex = marker.length;\n            if (endIndex !== text.nodeValue?.length) {\n                text.splitText(endIndex);\n            }\n\n            bind(text, variables, index++);\n\n        } else if (type === ELEMENT_NODE) {\n            element = node as Element;\n\n            if (element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE') {\n                walker.nextSibling();\n            }\n\n            if (isMarker(element.nodeName, marker)) {\n                bind(element, variables, index++);\n            }\n\n            names = element.getAttributeNames();\n            for (name of names) {\n                value = element.getAttribute(name) ?? '';\n\n                if (hasMarker(name, marker) || hasMarker(value, marker)) {\n                    attribute = element.getAttributeNode(name) as Attr;\n\n                    if (hasMarker(name, marker)) {\n                        bind(attribute, variables, index++);\n                    }\n\n                    if (hasMarker(value, marker)) {\n                        bind(attribute, variables, index++);\n                    }\n\n                } else {\n                    if (isLink(name)) {\n                        if (dangerousLink(value)) {\n                            element.removeAttribute(name);\n                            console.warn(`attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (hasOn(name)) {\n                        element.removeAttribute(name);\n                        console.warn(`attribute name \"${name}\" not allowed`);\n                    }\n                }\n            }\n        } else {\n            console.warn(`walker node type \"${type}\" not handled`);\n        }\n    }\n\n    if (typeof container === 'string') {\n        const selection = document.querySelector(container);\n        if (!selection) throw new Error('query not found');\n        replaceChildren(selection, fragment);\n        return selection;\n    } else if (container instanceof Element) {\n        replaceChildren(container, fragment)\n        return container;\n    } else {\n        return fragment;\n    }\n\n};\n", "import { InstanceSymbol, MarkerSymbol, TemplateSymbol, TemplatesCache, VariablesSymbol } from './global';\nimport { Initialize, Variables } from './types';\nimport { initialize } from './initialize';\nimport { update } from './update';\nimport { mark } from './tools';\n\n// const query = (node: Node, selector: Selector) => selector.reduce((n, s) => n[ s ], node);\n\nexport { update };\n\n/**\n *\n * @description\n * @param strings\n * @param variables\n * @returns {DocumentFragment}\n */\n\nexport const html = function (strings: TemplateStringsArray, ...variables: Variables): Initialize {\n    let marker: string;\n    let template: HTMLTemplateElement;\n\n    const cache = TemplatesCache.get(strings);\n\n    if (cache) {\n        marker = cache.marker;\n        template = cache.template;\n    } else {\n        marker = mark();\n\n        let innerHTML = '';\n\n        const length = strings.length - 1;\n        for (let index = 0; index < length; index++) {\n            innerHTML += `${strings[ index ]}${marker}`;\n        }\n\n        innerHTML += strings[ length ];\n\n        template = document.createElement('template');\n        template.innerHTML = innerHTML;\n\n        TemplatesCache.set(strings, { template, marker });\n    }\n\n    const meta = {\n        [ InstanceSymbol ]: true,\n        [ MarkerSymbol ]: marker,\n        [ TemplateSymbol ]: template,\n        [ VariablesSymbol ]: variables,\n    };\n\n    return Object.assign(initialize.bind(meta, template, variables, marker), meta);\n};\n"],
  "mappings": "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",
  "names": ["element", "attribute", "result", "owner", "node", "text", "attribute", "element"]
}
